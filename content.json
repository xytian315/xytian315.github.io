{"meta":{"title":"Kristy's blog","subtitle":"冰冻三尺非一日之寒","description":null,"author":"Kristy Tian","url":"http://xytian315.github.io"},"pages":[{"title":"Categories","date":"2016-09-09T02:26:22.000Z","updated":"2016-09-09T02:29:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://xytian315.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-01-16T14:17:29.000Z","updated":"2016-09-09T02:25:43.000Z","comments":false,"path":"tags/index.html","permalink":"http://xytian315.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-09-09T02:28:40.000Z","updated":"2016-09-09T02:30:03.000Z","comments":true,"path":"about/index.html","permalink":"http://xytian315.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 119 pascals traingle II","slug":"leetcode-119-pascals-traingle-II","date":"2016-12-03T06:31:44.000Z","updated":"2016-12-03T06:57:20.000Z","comments":true,"path":"2016/12/02/leetcode-119-pascals-traingle-II/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-119-pascals-traingle-II/","excerpt":"","text":"119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? Solution123456789101112131415161718192021//My solution, not O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; List&lt;Integer&gt; last = new ArrayList&lt;Integer&gt;(); last.add(1); if(rowIndex==0) return last; for(int j =1; j&lt;=rowIndex; j++)&#123; result = new ArrayList&lt;Integer&gt;(); result.add(1); for(int i=0;i&lt;last.size()-1;i++)&#123; result.add(last.get(i)+last.get(i+1)); &#125; result.add(1); last = result; &#125; return result; &#125;&#125; 1234567891011121314//O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; for(int i=0; i&lt;=rowIndex;i++)&#123; result.add(1); for(int j=i-1;j&gt;0;j--)&#123; result.set(j, result.get(j)+result.get(j-1)); &#125; &#125; return result; &#125;&#125; Notes思路： 从后往前算 in place replace","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 118 pascal's triangle","slug":"leetcode-118-pascal-s-triangle","date":"2016-12-03T05:35:44.000Z","updated":"2016-12-03T06:54:21.000Z","comments":true,"path":"2016/12/02/leetcode-118-pascal-s-triangle/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-118-pascal-s-triangle/","excerpt":"","text":"118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Solution123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(numRows&lt;=0) return result; List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;(); first.add(1); result.add(first); for(int i=2;i&lt;=numRows;i++)&#123; List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; last = result.get(result.size()-1); current.add(1); for(int j=0;j&lt;last.size()-1;j++)&#123; current.add(last.get(j)+last.get(j+1)); &#125; current.add(1); result.add(current); &#125; return result; &#125;&#125; Notes","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 283 Move zeroes","slug":"leetcode-283-Move-zeroes","date":"2016-12-03T03:19:28.000Z","updated":"2016-12-03T05:03:08.000Z","comments":true,"path":"2016/12/02/leetcode-283-Move-zeroes/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-283-Move-zeroes/","excerpt":"","text":"283. Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. Solution1234567891011121314151617public class Solution &#123; public void moveZeroes(int[] nums) &#123; int i =0; int count =0; while(i&lt;nums.length)&#123; if(nums[i]!=0)&#123; nums[count]=nums[i]; count++; &#125; i++; &#125; while(count&lt;nums.length)&#123; nums[count]=0; count++; &#125; &#125;&#125; Notes思路：O(n)time O(1) space1.loop the array from the beginning, use a slow runner to keep tracking the current index, if it is none zero, put that in the current index place. otherwise, continue.2.put 0 to the remaining indexes.","categories":[],"tags":[]},{"title":"leetcode 448 Find All Numbers Disappeared in an Array","slug":"leetcode-448-Find-All-Numbers-Disappeared-in-an-Array","date":"2016-12-02T06:47:49.000Z","updated":"2016-12-03T04:56:24.000Z","comments":true,"path":"2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","link":"","permalink":"http://xytian315.github.io/2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","excerpt":"","text":"Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] Notes思路：第一种简单解法O(n) space O(n) time1把数组中的所有数字放到一个set中2loop 从1到n, 如果数字i不在set中，即是答案disappeared number第二种优化解法O(1) space O(n)time1用index来标记是否数字出现于数组中， 如果数字在数组中，相应的index变成负数。nums[nums[i]-1] = -nums[nums[i]-1]2loop array, 如果数字是正数，说明这个数字没有出现在数组中，既是答案注：因为index是从0开始的，0到n-1, 而我们需要1到n, 所以纪录时要减1，最后结果要加1 Solution12345678910111213141516//O(n) space O(n) timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i =0; i&lt;nums.length;i++)&#123; set.add(nums[i]); &#125; for(int i=1; i&lt;= nums.length;i++)&#123; if(!set.contains(i))&#123; result.add(i); &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819// NO extra space solution O(1) space O(n)timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for(int i =0 ; i&lt;nums.length; i++)&#123; int value = Math.abs(nums[i])-1; if(nums[value]&gt;0)&#123; nums[value] = -nums[value]; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;0)&#123; result.add(i+1); &#125; &#125; return result; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 26 Remove Duplicates from Sorted Array","slug":"leetcode-26","date":"2016-10-03T23:13:09.000Z","updated":"2016-10-03T23:25:28.000Z","comments":true,"path":"2016/10/03/leetcode-26/","link":"","permalink":"http://xytian315.github.io/2016/10/03/leetcode-26/","excerpt":"","text":"26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. Notes:Two pointer techniquehttps://leetcode.com/articles/two-pointer-technique/two pointer: one fast runner, one slow runner Solution12345678910111213141516public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0 || nums.length == 1) return nums.length; int current = nums[0]; int count = 1; for(int i=1; i&lt; nums.length; i++) &#123; if(nums[i] != current) &#123; current = nums[i]; nums[count] = nums[i]; count++; &#125; &#125; return count; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"}]},{"title":"leetcode 189 Rotate Array","slug":"leetcode-189","date":"2016-09-12T19:06:08.000Z","updated":"2016-10-03T23:25:29.000Z","comments":true,"path":"2016/09/12/leetcode-189/","link":"","permalink":"http://xytian315.github.io/2016/09/12/leetcode-189/","excerpt":"","text":"189. Rotate ArrayRotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Solution12345678910111213public class Solution &#123; public void rotate(int[] nums, int k) &#123; if(k==0) return; k=k%(nums.length); for(int i =1; i&lt;=k; i++) &#123; int temp = nums[nums.length-1]; for(int j=nums.length-1; j&gt;0; j--) &#123; nums[j] = nums[j-1]; &#125; nums[0] = temp; &#125; &#125;&#125; Notes","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 11 Container With Most Water","slug":"leetcode-11","date":"2016-09-09T02:44:35.000Z","updated":"2016-10-03T23:26:11.000Z","comments":true,"path":"2016/09/08/leetcode-11/","link":"","permalink":"http://xytian315.github.io/2016/09/08/leetcode-11/","excerpt":"","text":"11. Container With Most Waterhttps://leetcode.com/problems/container-with-most-water/Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. Solution12","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"}]},{"title":"leetcode 169 Majority element","slug":"leetcode-169-Majority-element","date":"2016-09-01T06:12:06.000Z","updated":"2016-09-01T06:52:22.000Z","comments":true,"path":"2016/08/31/leetcode-169-Majority-element/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-169-Majority-element/","excerpt":"","text":"169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution1234567891011121314151617181920212223242526/** my solution sort**/public class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125;/** my solution map notes: remember to return immediately if the value is more n/2 times **/public class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums.length == 1) return nums[0]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt; nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; if(map.get(nums[i])&gt;=nums.length/2) return nums[i]; map.replace(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; return 0; &#125;&#125; Notes: sort will be o(nlog) time; hashmap will be o(n) timethere are also another genius solution o(n) time o(1) space so called Moores’s Voting algorithmhttps://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution12345678910111213141516public class Solution &#123; public int majorityElement(int[] num) &#123; int major=num[0], count = 1; for(int i=1; i&lt;num.length;i++)&#123; if(count==0)&#123; count++; major=num[i]; &#125;else if(major==num[i])&#123; count++; &#125;else count--; &#125; return major; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 66 Plus one","slug":"leetcode-66-Plus-one","date":"2016-09-01T05:43:16.000Z","updated":"2016-09-01T06:12:38.000Z","comments":true,"path":"2016/08/31/leetcode-66-Plus-one/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-66-Plus-one/","excerpt":"","text":"66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. Solution1234567891011121314151617181920212223242526272829303132/** my solution */public class Solution &#123; public int[] plusOne(int[] digits) &#123; int i = digits.length-1; int carry = 0; digits[i] = digits[i]+1; while(i&gt;=0)&#123; digits[i] = digits[i]+carry; if(digits[i]&gt;=10)&#123; digits[i] = digits[i]-10; carry=1; &#125;else&#123; carry=0; &#125; i--; &#125; if(carry == 0)&#123; return digits; &#125;else&#123; int[] result = new int[digits.length+1]; result[0]=1; int index=0; int j=1; while(index&lt;digits.length)&#123; result[j] = digits[index]; j++; index++; &#125; return result; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 88 Merge sorted array","slug":"leetcode-88-Merge-sorted-array","date":"2016-09-01T04:24:23.000Z","updated":"2016-09-02T21:39:44.000Z","comments":true,"path":"2016/08/31/leetcode-88-Merge-sorted-array/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-88-Merge-sorted-array/","excerpt":"","text":"88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. Solution123456789101112131415161718192021222324/** my solution **/public class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m-1; int j = n-1; int pointer = m+n-1; while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i]&gt;nums2[j])&#123; nums1[pointer] = nums1[i]; i--; &#125; else &#123; nums1[pointer] = nums2[j]; j--; &#125; pointer--; &#125; while(j&gt;=0)&#123; nums1[pointer]=nums2[j]; pointer--; j--; &#125; &#125;&#125; Notes: didn’t resolve the question from the first sight. got the hint from here http://algorithm.yuanbin.me/zh-hans/integer_array/merge_sorted_array.html 因为本题有 in-place 的限制，故必须从数组末尾的两个元素开始比较；否则就会产生挪动，一旦挪动就会是 O(n^2)的。 自尾部向首部逐个比较两个数组内的元素，取较大的置于数组 A 中。由于 A 的容量较 B 大，故最后 m == 0 或者 n == 0 时仅需处理 B 中的元素，因为 A 中的元素已经在 A 中，无需处理。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 27 Remove Element","slug":"leetcode-27-Remove-element","date":"2016-08-22T22:41:40.000Z","updated":"2016-10-03T23:25:21.000Z","comments":true,"path":"2016/08/22/leetcode-27-Remove-element/","link":"","permalink":"http://xytian315.github.io/2016/08/22/leetcode-27-Remove-element/","excerpt":"","text":"27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** my solution */public class Solution &#123; public int removeElement(int[] nums, int val) &#123; if (nums.length == 0) return 0; int start = 0; int end = nums.length-1; while (start&lt; end) &#123; if (nums[start] == val) &#123; if (nums[end] != val) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; else &#123; end--; &#125; &#125; else &#123; start++; &#125; &#125; if (nums[start]!= val) return start+1; else return start; &#125;&#125;/** jiuzhang solution */public class Solution &#123; public int removeElement(int[] nums, int val) &#123; if(nums == null || nums.length == 0 ) return 0; int i = 0; int pointer = nums.length-1; while (i &lt;= pointer)&#123; if (nums[i] == val)&#123; nums[i] = nums[pointer]; pointer--; &#125; else &#123; i++; &#125; &#125; return pointer+1; &#125;&#125;/** another solution easier to understand */public class Solution &#123; public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length == 0 ) return 0; int length = 0; for (int i=0; i&lt;nums.length; i++) &#123; if (nums[i] != val) &#123; nums[length] = nums[i]; length++; &#125; &#125; return length; &#125;&#125; NotesI did this question too comlicated since I didn’t notice the question said “it doesn’t matter what you leave beyond the new length”so you just need to focus on how many elements are equal to the value. you can change the value of the elements in the array.Read the question more carefully, it asked you to return the new length, not how many elements equal to the value. Use two pointers, one pointer to loop the array, the other pointer to record how many elements are equal to the value.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 7 Reverse Integer","slug":"leetcode-7-Reverse-Integer","date":"2016-08-10T04:34:29.000Z","updated":"2016-08-10T04:35:31.000Z","comments":true,"path":"2016/08/09/leetcode-7-Reverse-Integer/","link":"","permalink":"http://xytian315.github.io/2016/08/09/leetcode-7-Reverse-Integer/","excerpt":"","text":"7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 12 Notes:Do not forget to think about overflow problem.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 6 ZigZag Conversion","slug":"leetcode-6","date":"2016-08-09T04:47:46.000Z","updated":"2016-09-09T02:22:53.000Z","comments":true,"path":"2016/08/08/leetcode-6/","link":"","permalink":"http://xytian315.github.io/2016/08/08/leetcode-6/","excerpt":"","text":"6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/ Solution12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if (s == null || s.isEmpty() || numRows &lt;= 1 || numRows &gt;= s.length()) return s; int length = s.length(); int step = 2*(numRows-1); int count = 0; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; numRows; i++)&#123; int interval = step-2*i; for(int j = i; j &lt; length; j+=step)&#123; sb.append(s.charAt(j)); count++; if(interval &gt;0 &amp;&amp; interval != step &amp;&amp; count &lt; length &amp;&amp; (j+interval)&lt;length )&#123; sb.append(s.charAt(j+interval)); count++; &#125; &#125; &#125; return sb.toString(); &#125;&#125; Notes:I have no idea how to do this question at first, stucking for a whilehere is the solution https://kevinclcn.gitbooks.io/leetcodejava/content/006_zigzag_conversion.html","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 5 Longest Palindromic Substring","slug":"leetcode-5","date":"2016-08-05T14:00:47.000Z","updated":"2016-09-09T02:22:44.000Z","comments":true,"path":"2016/08/05/leetcode-5/","link":"","permalink":"http://xytian315.github.io/2016/08/05/leetcode-5/","excerpt":"","text":"5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Solution12345678910111213141516171819202122232425262728/* * I only did the brute force solution O(n3) */ public class Solution &#123; public String longestPalindrome(String s) &#123; if(s.isEmpty() || s.length() == 1) return s; String result = \"\"; for(int i = 0; i &lt; s.length(); i++)&#123; for(int j = i+1; j&lt; s.length(); j++)&#123; if(isPalindrome(s, i, j) &amp;&amp; result.length() &lt; j-i+1)&#123; result = s.substring(i,j+1); &#125; &#125; &#125; int return result; &#125; public Boolean isPalindrome(String s, int i , int j)&#123; while(i&lt;j)&#123; if(s.charAt(i)!=s.charAt(j)) return false; i++; j--; &#125; return true; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"leetcode 3 Longest Substring Without Repeating Characters","slug":"leetcode-3","date":"2016-08-04T23:44:34.000Z","updated":"2016-09-09T02:21:53.000Z","comments":true,"path":"2016/08/04/leetcode-3/","link":"","permalink":"http://xytian315.github.io/2016/08/04/leetcode-3/","excerpt":"","text":"3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Solution1234567891011121314151617181920212223242526/**my solution without looking at the answers*/public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.isEmpty()) return 0; int result = 0; int start = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; if(map.containsKey(s.charAt(i))) &#123; if(result &lt; i - start ) &#123; result = i - start; &#125; if(map.get(s.charAt(i))+1 &gt; start)&#123; start = map.get(s.charAt(i)) + 1; &#125; &#125; map.put(s.charAt(i), i); &#125; if(result &lt; s.length()-start) &#123; result = s.length()-start; &#125; return result; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"how to implement a singly LinkedList","slug":"how-to-implement-a-singly-LinkedList","date":"2016-08-02T23:02:36.000Z","updated":"2016-08-02T23:08:14.000Z","comments":true,"path":"2016/08/02/how-to-implement-a-singly-LinkedList/","link":"","permalink":"http://xytian315.github.io/2016/08/02/how-to-implement-a-singly-LinkedList/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SinglyLinkedList&lt;E&gt; &#123; /** * Nested node class */ private static class Node&lt;E&gt; &#123; private E element; private Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; public E getElement() &#123; return this.element; &#125; public Node&lt;E&gt; getNext() &#123; return this.next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; /** * end of nested node class */ private Node&lt;E&gt; head = null; private Node&lt;E&gt; tail = null; private Integer size = 0; public SinglyLinkedList() &#123; &#125; public Integer size() &#123; return this.size; &#125; public Boolean isEmpty() &#123; return this.size == 0; &#125; public E first() &#123; if(isEmpty()) return null; return head.getElement(); &#125; public E last() &#123; if(isEmpty()) return null; return tail.getElement(); &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newHead = new Node(e, head); this.head = newHead; size++; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node(e, null); if(isEmpty())&#123; head = newNode; &#125;else &#123; tail.setNext(newNode); this.tail = newNode; &#125; size++; &#125; public E removeFirst() &#123; if(isEmpty()) return null; E result = head.getElement(); this.head = head.getNext(); size--; return result; &#125;&#125; NotesNested class: when defining a class which is strongly affiliated with another class helps to increase encapsulation and avoid name conflicts Static means its value/method is associated with the class itself, rather than with each individual instance of the class.That means it is not invoked on a particular instance of the class using traditional dot notation.Instead, it is typically using the name of the class as a qualifier. useful for providing utility behaviors related to a class that need not rely on the state of any particular instance of the class.","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 2 Add Two Numbers","slug":"leetcode-2-Add-two-numbers","date":"2016-07-20T06:34:59.000Z","updated":"2016-09-09T02:21:48.000Z","comments":true,"path":"2016/07/19/leetcode-2-Add-two-numbers/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-2-Add-two-numbers/","excerpt":"","text":"2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ /** Wrote the following solution without seeing other people's solutions **/public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode tail = null; int count = 0; while(l1 != null || l2 != null) &#123; if(l1 != null)&#123; count += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; count += l2.val; l2 = l2.next; &#125; ListNode ln = new ListNode(count%10); if(head == null) &#123; head = ln; tail = ln; &#125;else &#123; tail.next = ln; tail=ln; &#125; count = count/10; &#125; if(count&gt;0) &#123; tail.next= new ListNode(count); &#125; return head; &#125;&#125; Note","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"leetcode 1","slug":"leetcode-1","date":"2016-07-20T05:03:20.000Z","updated":"2016-09-02T21:39:31.000Z","comments":true,"path":"2016/07/19/leetcode-1/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-1/","excerpt":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].","text":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i&lt; nums.length; i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]), i&#125;; &#125;else&#123; map.put(nums[i],i); &#125; &#125; return null; &#125;&#125; NoteMap","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]}]}