{"meta":{"title":"Kristy's blog","subtitle":"冰冻三尺非一日之寒","description":null,"author":"Kristy Tian","url":"http://xytian315.github.io"},"pages":[],"posts":[{"title":"leetcode 3","slug":"leetcode-3","date":"2016-08-04T23:44:34.000Z","updated":"2016-08-05T03:10:14.000Z","comments":true,"path":"2016/08/04/leetcode-3/","link":"","permalink":"http://xytian315.github.io/2016/08/04/leetcode-3/","excerpt":"","text":"3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Solution` java public class Solution { public int lengthOfLongestSubstring(String s) { if (s.isEmpty()) return 0; int result = 0; int start = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt; s.length(); i++) { if(map.containsKey(s.charAt(i))) { if(result &lt; i - start ) { result = i - start; } if(map.get(s.charAt(i))+1 &gt; start){ start = map.get(s.charAt(i)) + 1; } } map.put(s.charAt(i), i); } if(result &lt; s.length()-start) { result = s.length()-start; } return result; } }","categories":[],"tags":[]},{"title":"how to implement a singly LinkedList","slug":"how-to-implement-a-singly-LinkedList","date":"2016-08-02T23:02:36.000Z","updated":"2016-08-02T23:08:14.000Z","comments":true,"path":"2016/08/02/how-to-implement-a-singly-LinkedList/","link":"","permalink":"http://xytian315.github.io/2016/08/02/how-to-implement-a-singly-LinkedList/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SinglyLinkedList&lt;E&gt; &#123; /** * Nested node class */ private static class Node&lt;E&gt; &#123; private E element; private Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; public E getElement() &#123; return this.element; &#125; public Node&lt;E&gt; getNext() &#123; return this.next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; /** * end of nested node class */ private Node&lt;E&gt; head = null; private Node&lt;E&gt; tail = null; private Integer size = 0; public SinglyLinkedList() &#123; &#125; public Integer size() &#123; return this.size; &#125; public Boolean isEmpty() &#123; return this.size == 0; &#125; public E first() &#123; if(isEmpty()) return null; return head.getElement(); &#125; public E last() &#123; if(isEmpty()) return null; return tail.getElement(); &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newHead = new Node(e, head); this.head = newHead; size++; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node(e, null); if(isEmpty())&#123; head = newNode; &#125;else &#123; tail.setNext(newNode); this.tail = newNode; &#125; size++; &#125; public E removeFirst() &#123; if(isEmpty()) return null; E result = head.getElement(); this.head = head.getNext(); size--; return result; &#125;&#125; NotesNested class: when defining a class which is strongly affiliated with another class helps to increase encapsulation and avoid name conflicts Static means its value/method is associated with the class itself, rather than with each individual instance of the class.That means it is not invoked on a particular instance of the class using traditional dot notation.Instead, it is typically using the name of the class as a qualifier. useful for providing utility behaviors related to a class that need not rely on the state of any particular instance of the class.","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 2","slug":"leetcode-2","date":"2016-07-20T06:34:59.000Z","updated":"2016-08-04T23:28:41.000Z","comments":true,"path":"2016/07/19/leetcode-2/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-2/","excerpt":"","text":"2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ /** Wrote the following solution without seeing other people's solutions **/public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode tail = null; int count = 0; while(l1 != null || l2 != null) &#123; if(l1 != null)&#123; count += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; count += l2.val; l2 = l2.next; &#125; ListNode ln = new ListNode(count%10); if(head == null) &#123; head = ln; tail = ln; &#125;else &#123; tail.next = ln; tail=ln; &#125; count = count/10; &#125; if(count&gt;0) &#123; tail.next= new ListNode(count); &#125; return head; &#125;&#125; Note","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"Medium","slug":"Medium","permalink":"http://xytian315.github.io/tags/Medium/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 1","slug":"leetcode-1","date":"2016-07-20T05:03:20.000Z","updated":"2016-07-20T06:52:08.000Z","comments":true,"path":"2016/07/19/leetcode-1/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-1/","excerpt":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].","text":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i&lt; nums.length; i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]), i&#125;; &#125;else&#123; map.put(nums[i],i); &#125; &#125; return null; &#125;&#125; NoteMap","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"},{"name":"Easy","slug":"Easy","permalink":"http://xytian315.github.io/tags/Easy/"}]}]}