{"meta":{"title":"Kristy's blog","subtitle":"冰冻三尺非一日之寒","description":null,"author":"Kristy Tian","url":"http://xytian315.github.io"},"pages":[],"posts":[{"title":"leetcode-27","slug":"leetcode-27","date":"2016-08-22T22:41:40.000Z","updated":"2016-09-01T03:07:52.000Z","comments":true,"path":"2016/08/22/leetcode-27/","link":"","permalink":"http://xytian315.github.io/2016/08/22/leetcode-27/","excerpt":"","text":"27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. Solution123456789101112131415161718192021222324252627/** my solution **/public class Solution &#123; public int removeElement(int[] nums, int val) &#123; if (nums.length == 0) return 0; int start = 0; int end = nums.length-1; while (start&lt; end) &#123; if (nums[start] == val) &#123; if (nums[end] != val) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; else &#123; end--; &#125; &#125; else &#123; start++; &#125; &#125; if (nums[start]!= val) return start+1; else return start; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 7 Reverse Integer","slug":"leetcode-7-Reverse-Integer","date":"2016-08-10T04:34:29.000Z","updated":"2016-08-10T04:35:31.000Z","comments":true,"path":"2016/08/09/leetcode-7-Reverse-Integer/","link":"","permalink":"http://xytian315.github.io/2016/08/09/leetcode-7-Reverse-Integer/","excerpt":"","text":"7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 12 Notes:Do not forget to think about overflow problem.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 6","slug":"leetcode-6","date":"2016-08-09T04:47:46.000Z","updated":"2016-08-09T06:25:06.000Z","comments":true,"path":"2016/08/08/leetcode-6/","link":"","permalink":"http://xytian315.github.io/2016/08/08/leetcode-6/","excerpt":"","text":"6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/ Solution12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if (s == null || s.isEmpty() || numRows &lt;= 1 || numRows &gt;= s.length()) return s; int length = s.length(); int step = 2*(numRows-1); int count = 0; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; numRows; i++)&#123; int interval = step-2*i; for(int j = i; j &lt; length; j+=step)&#123; sb.append(s.charAt(j)); count++; if(interval &gt;0 &amp;&amp; interval != step &amp;&amp; count &lt; length &amp;&amp; (j+interval)&lt;length )&#123; sb.append(s.charAt(j+interval)); count++; &#125; &#125; &#125; return sb.toString(); &#125;&#125; Notes:I have no idea how to do this question at first, stucking for a whilehere is the solution https://kevinclcn.gitbooks.io/leetcodejava/content/006_zigzag_conversion.html","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 5","slug":"leetcode-5","date":"2016-08-05T14:00:47.000Z","updated":"2016-08-09T04:47:30.000Z","comments":true,"path":"2016/08/05/leetcode-5/","link":"","permalink":"http://xytian315.github.io/2016/08/05/leetcode-5/","excerpt":"","text":"5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Solution12345678910111213141516171819202122232425262728/* * I only did the brute force solution O(n3) */ public class Solution &#123; public String longestPalindrome(String s) &#123; if(s.isEmpty() || s.length() == 1) return s; String result = \"\"; for(int i = 0; i &lt; s.length(); i++)&#123; for(int j = i+1; j&lt; s.length(); j++)&#123; if(isPalindrome(s, i, j) &amp;&amp; result.length() &lt; j-i+1)&#123; result = s.substring(i,j+1); &#125; &#125; &#125; int return result; &#125; public Boolean isPalindrome(String s, int i , int j)&#123; while(i&lt;j)&#123; if(s.charAt(i)!=s.charAt(j)) return false; i++; j--; &#125; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"leetcode 3","slug":"leetcode-3","date":"2016-08-04T23:44:34.000Z","updated":"2016-08-05T03:24:06.000Z","comments":true,"path":"2016/08/04/leetcode-3/","link":"","permalink":"http://xytian315.github.io/2016/08/04/leetcode-3/","excerpt":"","text":"3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Solution1234567891011121314151617181920212223242526/**my solution without looking at the answers*/public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.isEmpty()) return 0; int result = 0; int start = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; if(map.containsKey(s.charAt(i))) &#123; if(result &lt; i - start ) &#123; result = i - start; &#125; if(map.get(s.charAt(i))+1 &gt; start)&#123; start = map.get(s.charAt(i)) + 1; &#125; &#125; map.put(s.charAt(i), i); &#125; if(result &lt; s.length()-start) &#123; result = s.length()-start; &#125; return result; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"}]},{"title":"how to implement a singly LinkedList","slug":"how-to-implement-a-singly-LinkedList","date":"2016-08-02T23:02:36.000Z","updated":"2016-08-02T23:08:14.000Z","comments":true,"path":"2016/08/02/how-to-implement-a-singly-LinkedList/","link":"","permalink":"http://xytian315.github.io/2016/08/02/how-to-implement-a-singly-LinkedList/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SinglyLinkedList&lt;E&gt; &#123; /** * Nested node class */ private static class Node&lt;E&gt; &#123; private E element; private Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; public E getElement() &#123; return this.element; &#125; public Node&lt;E&gt; getNext() &#123; return this.next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; /** * end of nested node class */ private Node&lt;E&gt; head = null; private Node&lt;E&gt; tail = null; private Integer size = 0; public SinglyLinkedList() &#123; &#125; public Integer size() &#123; return this.size; &#125; public Boolean isEmpty() &#123; return this.size == 0; &#125; public E first() &#123; if(isEmpty()) return null; return head.getElement(); &#125; public E last() &#123; if(isEmpty()) return null; return tail.getElement(); &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newHead = new Node(e, head); this.head = newHead; size++; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node(e, null); if(isEmpty())&#123; head = newNode; &#125;else &#123; tail.setNext(newNode); this.tail = newNode; &#125; size++; &#125; public E removeFirst() &#123; if(isEmpty()) return null; E result = head.getElement(); this.head = head.getNext(); size--; return result; &#125;&#125; NotesNested class: when defining a class which is strongly affiliated with another class helps to increase encapsulation and avoid name conflicts Static means its value/method is associated with the class itself, rather than with each individual instance of the class.That means it is not invoked on a particular instance of the class using traditional dot notation.Instead, it is typically using the name of the class as a qualifier. useful for providing utility behaviors related to a class that need not rely on the state of any particular instance of the class.","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 2","slug":"leetcode-2","date":"2016-07-20T06:34:59.000Z","updated":"2016-08-04T23:28:41.000Z","comments":true,"path":"2016/07/19/leetcode-2/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-2/","excerpt":"","text":"2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ /** Wrote the following solution without seeing other people's solutions **/public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode tail = null; int count = 0; while(l1 != null || l2 != null) &#123; if(l1 != null)&#123; count += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; count += l2.val; l2 = l2.next; &#125; ListNode ln = new ListNode(count%10); if(head == null) &#123; head = ln; tail = ln; &#125;else &#123; tail.next = ln; tail=ln; &#125; count = count/10; &#125; if(count&gt;0) &#123; tail.next= new ListNode(count); &#125; return head; &#125;&#125; Note","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"Medium","slug":"Medium","permalink":"http://xytian315.github.io/tags/Medium/"}]},{"title":"leetcode 1","slug":"leetcode-1","date":"2016-07-20T05:03:20.000Z","updated":"2016-07-20T06:52:08.000Z","comments":true,"path":"2016/07/19/leetcode-1/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-1/","excerpt":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].","text":"1. Two sumhttps://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i&lt; nums.length; i++)&#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]), i&#125;; &#125;else&#123; map.put(nums[i],i); &#125; &#125; return null; &#125;&#125; NoteMap","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"},{"name":"Easy","slug":"Easy","permalink":"http://xytian315.github.io/tags/Easy/"}]}]}