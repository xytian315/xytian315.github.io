{"meta":{"title":"Kristy's blog","subtitle":null,"description":null,"author":"Kristy Tian","url":"http://xytian315.github.io"},"pages":[{"title":"About","date":"2016-09-09T02:28:40.000Z","updated":"2016-09-09T02:30:03.000Z","comments":true,"path":"about/index.html","permalink":"http://xytian315.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-06T04:58:03.000Z","updated":"2016-12-06T04:58:03.000Z","comments":true,"path":"categories/index-1.html","permalink":"http://xytian315.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-06T03:55:51.000Z","updated":"2016-12-06T03:55:51.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://xytian315.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"All tags","date":"2014-12-22T20:39:04.000Z","updated":"2016-12-06T04:36:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://xytian315.github.io/tags/index.html","excerpt":"","text":""},{"title":"All categories","date":"2014-12-22T20:39:04.000Z","updated":"2016-12-06T05:01:28.000Z","comments":true,"path":"categories/index.html","permalink":"http://xytian315.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 299 Bulls and Cows","slug":"leetcode-299-Bulls-and-Cows","date":"2016-12-09T06:42:54.000Z","updated":"2016-12-10T06:48:04.000Z","comments":true,"path":"2016/12/08/leetcode-299-Bulls-and-Cows/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-299-Bulls-and-Cows/","excerpt":"Question: 299. Bulls and CowsYou are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.","text":"Question: 299. Bulls and CowsYou are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//solution from discussionpublic class Solution &#123; public String getHint(String secret, String guess) &#123; int[] numbers = new int[10]; int bulls=0; int cows=0; for(int i=0;i&lt;secret.length();i++)&#123; int s = Character.getNumericValue(secret.charAt(i)); int g = Character.getNumericValue(guess.charAt(i)); if(s==g)&#123; bulls++; &#125;else&#123; if(numbers[s]&lt;0) cows++; if(numbers[g]&gt;0) cows++; numbers[s]++; numbers[g]--; &#125; &#125; return bulls+\"A\"+cows+\"B\"; &#125;&#125;//my complicated solutionpublic class Solution &#123; public String getHint(String secret, String guess) &#123; int bulls =0; int cows =0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;secret.length();i++)&#123; if(secret.charAt(i)==guess.charAt(i))&#123; bulls++; set.add(i); &#125; else &#123; Character s = secret.charAt(i); if (map.containsKey(s)) &#123; map.put(s, map.get(s) + 1); &#125; else &#123; map.put(s, 1); &#125; &#125; &#125; for(int i=0;i&lt;guess.length();i++)&#123; Character g = guess.charAt(i); if(map.containsKey(g)&amp;&amp;!set.contains(i))&#123; map.put(g,map.get(g)-1); if(map.get(g) &gt;=0) cows++; &#125; &#125; StringBuilder sb=new StringBuilder(); sb.append(bulls); sb.append(\"A\"); sb.append(cows); sb.append(\"B\"); return sb.toString(); &#125;&#125; ThoughtsThe idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 242 Valid Anagram","slug":"leetcode-242-Valid-Anagram","date":"2016-12-09T05:35:06.000Z","updated":"2016-12-09T07:13:34.000Z","comments":true,"path":"2016/12/08/leetcode-242-Valid-Anagram/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-242-Valid-Anagram/","excerpt":"Question: 242. Valid AnagramGiven two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case?","text":"Question: 242. Valid AnagramGiven two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//use arraypublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; int[] chars= new int[26]; for(int i=0;i&lt;s.length();i++)&#123; chars[s.charAt(i)-'a']++; chars[t.charAt(i)-'a']--; &#125; for(int element:chars)&#123; if(element!=0)&#123; return false; &#125; &#125; return true; &#125;&#125;//use mappublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; map.put(s.charAt(i), map.get(s.charAt(i))+1); &#125;else&#123; map.put(s.charAt(i),1); &#125; &#125; for(int i=0;i&lt;t.length();i++)&#123; if(map.containsKey(t.charAt(i)) &amp;&amp; (map.get(t.charAt(i))&gt;0)) &#123; map.put(t.charAt(i),map.get(t.charAt(i))-1); &#125;else&#123; return false; &#125; &#125; return true; &#125;&#125;//my solution//the strings only include 26 english letter, I don't need to use ASCII 256 lengthpublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; int[] chars = new int[256]; int[] chart = new int[256]; for(int i=0;i&lt;256;i++)&#123; chars[i]=chart[i]=0; &#125; for(int i=0;i&lt;s.length();i++)&#123; chars[s.charAt(i)]=chars[s.charAt(i)]+1; chart[t.charAt(i)]=chart[t.charAt(i)]+1; &#125; for(int i=0;i&lt;256;i++)&#123; if(chars[i]!=chart[i]) return false; &#125; return true; &#125;&#125; ThoughtsWe can use a map or an array to keep tracking,the total number for the same character should be the same. the difference of the number should be 0.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 205 Isomorphic strings","slug":"leetcode-205-Isomorphic-strings","date":"2016-12-09T03:56:50.000Z","updated":"2016-12-09T04:13:12.000Z","comments":true,"path":"2016/12/08/leetcode-205-Isomorphic-strings/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-205-Isomorphic-strings/","excerpt":"Question: 205. Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.","text":"Question: 205. Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Solution1234567891011121314151617public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); for(int i=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; if(map.get(s.charAt(i))!=t.charAt(i)) return false; &#125;else&#123; if(map.containsValue((t.charAt(i)))) return false; map.put(s.charAt(i), t.charAt(i)); &#125; &#125; return true; &#125;&#125; ThoughtsKeywords: No two characters may map to the same character.define a map which tracks the char-char mappings. If a value is already mapped, it can not be mapped again.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 204 count primes","slug":"leetcode-204-count-primes","date":"2016-12-08T03:13:02.000Z","updated":"2016-12-08T03:18:50.000Z","comments":true,"path":"2016/12/07/leetcode-204-count-primes/","link":"","permalink":"http://xytian315.github.io/2016/12/07/leetcode-204-count-primes/","excerpt":"Question: 204. Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n.","text":"Question: 204. Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n. Solutionpublic class Solution { public int countPrimes(int n) { boolean[] notPrime = new boolean[n]; int count=0; for(int i=2;i&lt;n;i++){ if(notPrime[i]==false){ count++; int j=2; while(i*j&lt;=n-1){ notPrime[i*j]=true; j++; } } } return count; } } Thoughts:use boolean array to record if it is prime or notthe initial value of boolean is false","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 202 Happy number","slug":"leetcode-202-Happy-number","date":"2016-12-07T06:43:35.000Z","updated":"2016-12-07T06:47:41.000Z","comments":true,"path":"2016/12/06/leetcode-202-Happy-number/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-202-Happy-number/","excerpt":"Question: 202. Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1","text":"Question: 202. Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 Solution12345678910111213141516public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int sum = 0; while(set.add(n))&#123; sum=0; while(n&gt;0)&#123; sum +=(n%10)*(n%10); n=n/10; &#125; if(sum==1) return true; n=sum; &#125; return false; &#125;&#125; Thoughts Endless cycle is the hint for using the set to track the numbers since if it is endless cycle, it must return the same number again. Use a while loop to keep summing the numbers","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 136 Single number","slug":"leetcode-136-Single-number","date":"2016-12-07T05:18:33.000Z","updated":"2016-12-07T06:44:11.000Z","comments":true,"path":"2016/12/06/leetcode-136-Single-number/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-136-Single-number/","excerpt":"Question: 136. Single NumberGiven an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?","text":"Question: 136. Single NumberGiven an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//the solution from discussion//O(n) time 0 extra space//A XOR A = 0 and the XOR operator is commutativepublic class Solution &#123; public int singleNumber(int[] nums) &#123; int result = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; result=result^nums[i]; &#125; return result; &#125;&#125;//mysolution1 O(n) time O(n) extra spacepublic class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums.length==1) return nums[0]; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int element: nums)&#123; if(!set.add(element))&#123; set.remove(element); &#125;else&#123; set.add(element); &#125; &#125; Object[] result =set.toArray() return (int)result[0]; &#125;&#125;//mysolution2 O(n) time O(n) extra spacepublic class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums.length==1) return nums[0]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int element: nums)&#123; if(map.containsKey(element))&#123; map.put(element,map.get(element)+1); &#125;else&#123; map.put(element,1); &#125; &#125; for(int element:nums)&#123; if(map.get(element)==1) return element; &#125; return nums[0]; &#125;&#125; Thoughtsif without extra space, thinking about bit manipulation?XOR bitwise manipulation A XOR A = 0; A XOR A XOR B = B;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 36 valid sudoku","slug":"leetcode-36-valid-sudoku","date":"2016-12-07T04:31:17.000Z","updated":"2016-12-07T04:46:07.000Z","comments":true,"path":"2016/12/06/leetcode-36-valid-sudoku/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-36-valid-sudoku/","excerpt":"Question: 36. Valid SudokuDetermine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.","text":"Question: 36. Valid SudokuDetermine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; //validate rows if (!validate(i, i + 1, 0, 9, board)) return false; //validate cols if (!validate(0, 9, i, i + 1, board)) return false; &#125; //validate cells for (int i = 0; i &lt; 9; i += 3) &#123; for (int j = 0; j &lt; 9; j += 3) &#123; if (!validate(i, i + 3, j, j + 3, board)) return false; &#125; &#125; return true; &#125; public boolean validate(int rowStart, int rowEnd, int colStart, int colEnd, char[][] board) &#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for (int i = rowStart; i &lt; rowEnd; i++) &#123; for (int j = colStart; j &lt; colEnd; j++) &#123; if (!set.add(board[i][j]) &amp;&amp; board[i][j] != '.') &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;//my first time solutionpublic class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; //validate rows for (int i = 0; i &lt; 9; i++) &#123; if (!validate(i, i + 1, 0, 9, board)) return false; &#125; //validate columns for (int i = 0; i &lt; 9; i++) &#123; if (!validate(0, 9, i, i + 1, board)) return false; &#125; //validate cells for (int i = 0; i &lt; 9; i += 3) &#123; for (int j = 0; j &lt; 9; j += 3) &#123; if (!validate(i, i + 3, j, j + 3, board)) return false; &#125; &#125; return true; &#125; public boolean validate(int rowStart, int rowEnd, int colStart, int colEnd, char[][] board) &#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for (int i = rowStart; i &lt; rowEnd; i++) &#123; for (int j = colStart; j &lt; colEnd; j++) &#123; if (!set.add(board[i][j]) &amp;&amp; board[i][j] != '.') &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; Thoughts Soduku will be always 9rows 9 columns I don’t need to get the length like this board.length always checking if we can refactor it. make it DRY","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 414 Third Maximum number","slug":"leetcode-414-Third-Maximum-number","date":"2016-12-06T05:55:27.000Z","updated":"2016-12-06T05:58:09.000Z","comments":true,"path":"2016/12/05/leetcode-414-Third-Maximum-number/","link":"","permalink":"http://xytian315.github.io/2016/12/05/leetcode-414-Third-Maximum-number/","excerpt":"Question: 414. Third Maximum NumberGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1:Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.Example 2:Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.","text":"Question: 414. Third Maximum NumberGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1:Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.Example 2:Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. Solution123456789101112131415161718192021222324public class Solution &#123; public int thirdMax(int[] nums) &#123; long max = Long.MIN_VALUE; long mid = Long.MIN_VALUE;; long min = Long.MIN_VALUE; for(int i: nums)&#123; if(i&gt;max)&#123; min=mid; mid=max; max=i; &#125;else if(i&lt;max &amp;&amp; i&gt;mid)&#123; min=mid; mid=i; &#125;else if(i&gt;min &amp;&amp; i&lt;mid)&#123; min=i; &#125; &#125; if(min!=Long.MIN_VALUE)&#123; return (int)min; &#125;else&#123; return (int)max; &#125; &#125;&#125; Thoughtsshould use long to initiate min value","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 88 Merge sorted array","slug":"leetcode-88-merge-sorted-array-0","date":"2016-12-06T00:37:50.000Z","updated":"2016-12-06T05:14:13.000Z","comments":true,"path":"2016/12/05/leetcode-88-merge-sorted-array-0/","link":"","permalink":"http://xytian315.github.io/2016/12/05/leetcode-88-merge-sorted-array-0/","excerpt":"Question: 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.","text":"Question: 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//not good solution did by myselfpublic class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int start1=0; int start2=0; int start =0; int[] temp = nums1.clone(); while(start1&lt;m &amp;&amp; start2&lt;n)&#123; if(temp[start1]&lt;=nums2[start2])&#123; nums1[start]=temp[start1]; start1++; &#125;else&#123; nums1[start]=nums2[start2]; start2++; &#125; start++; &#125; if(start1!=m)&#123; while(start1&lt;m)&#123; nums1[start]=temp[start1]; start1++; start++; &#125; &#125; if(start2!=n)&#123; while(start2&lt;n)&#123; nums1[start]=nums2[start2]; start2++; start++; &#125; &#125; &#125;&#125;//better solution after reading the discussionpublic class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i=m-1; int j=n-1; int index = m+n-1; while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i]&gt;=nums2[j])&#123; nums1[index]=nums1[i]; i--; &#125;else&#123; nums1[index]=nums2[j]; j--; &#125; index--; &#125; while(j&gt;=0)&#123; nums1[index]=nums2[j]; j--; index--; &#125; &#125;&#125; Thoughtswhen doing things in place in array, thinking about starting backwords.also noted after comparing two array, we only need to check if nums2 is already finished do not need to check nums1 since nums1’s elements are already in the right place","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 27 remove element","slug":"leetcode-27-remove-element-0","date":"2016-12-04T20:28:35.000Z","updated":"2016-12-06T05:13:22.000Z","comments":true,"path":"2016/12/04/leetcode-27-remove-element-0/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-27-remove-element-0/","excerpt":"Question: 27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2.","text":"Question: 27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. Solution//my solution public class Solution { public int removeElement(int[] nums, int val) { int current =0; for(int i =0;i&lt;nums.length;i++){ if(nums[i]!=val){ nums[current]=nums[i]; current++; } } return current; } } Thoughtsreturn current not (current+1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 1 two sum","slug":"leetcode-1-two-sum","date":"2016-12-04T20:11:31.000Z","updated":"2016-12-07T05:33:35.000Z","comments":true,"path":"2016/12/04/leetcode-1-two-sum/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-1-two-sum/","excerpt":"Question: 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].","text":"Question: 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213141516public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; result[0]=map.get(target-nums[i]); result[1]=i; return result; &#125;else&#123; map.put(nums[i], i); &#125; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 219 contains duplicate II","slug":"leetcode-219-contains-duplicate-II","date":"2016-12-04T18:17:25.000Z","updated":"2016-12-09T04:17:55.000Z","comments":true,"path":"2016/12/04/leetcode-219-contains-duplicate-II/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-219-contains-duplicate-II/","excerpt":"Question: 219. Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.","text":"Question: 219. Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. Solution123456789101112131415//my solution use a hashmappublic class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if(nums.length&lt;=1 || k&lt;1) return false; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i&lt; nums.length; i++)&#123; if(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i])&lt;=k))&#123; return true; &#125;else&#123; map.put(nums[i],i); &#125; &#125; return false; &#125;&#125; 1234567891011//better solution you can use hashset public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 217 contains duplicate","slug":"leetcode-217-contains-duplicate","date":"2016-12-03T23:21:20.000Z","updated":"2016-12-09T04:15:00.000Z","comments":true,"path":"2016/12/03/leetcode-217-contains-duplicate/","link":"","permalink":"http://xytian315.github.io/2016/12/03/leetcode-217-contains-duplicate/","excerpt":"Question: 217. Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.","text":"Question: 217. Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Solution123456789101112131415//time O(n) space O(n)public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; if(nums.length&lt;=1) return false; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i =0;i&lt;nums.length;i++)&#123; if(set.contains(nums[i]))&#123; return true; &#125;else&#123; set.add(nums[i]); &#125; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 121 best time to buy and sell stock","slug":"leetcode-121-best-time-to-buy-and-sell-stock","date":"2016-12-03T20:35:27.000Z","updated":"2016-12-06T05:12:56.000Z","comments":true,"path":"2016/12/03/leetcode-121-best-time-to-buy-and-sell-stock/","link":"","permalink":"http://xytian315.github.io/2016/12/03/leetcode-121-best-time-to-buy-and-sell-stock/","excerpt":"Question: 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0.","text":"Question: 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. Solution1234567891011121314//after reading kadane's algorithm, I wrote this solution//O(n) timepublic class Solution &#123; public int maxProfit(int[] prices) &#123; int max = 0; if(prices.length == 0) return max; int start =prices[prices.length-1]; for(int i=prices.length-2;i&gt;=0;i--)&#123; start= Math.max(prices[i], start); max=Math.max(max,start-prices[i]); &#125; return max; &#125;&#125; 1234567891011121314151617181920//brute force//O(n2)timepublic class Solution &#123; public int maxProfit(int[] prices) &#123; int result =0; int index = prices.length-1; while(index&gt;=1)&#123; int j = index-1; while(j&gt;=0)&#123; int profit = prices[index]-prices[j]; if(profit&gt;result)&#123; result=profit; &#125; j--; &#125; index--; &#125; return result; &#125;&#125; Thoughtsmax subarray problem (kadane’s algorithm) https://en.wikipedia.org/wiki/Maximum_subarray_problem Kadane’s algorithm consists of a scan through the array values, computing at each position the maximum (positive sum) subarray ending at that position. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous position. The algorithm only needs to keep track of the ending position because the implied starting position is just after the last position at which the sum went negative; a higher sum can always be found by dropping any negative-sum prefix. Thus, the problem can be solved with the following code, expressed here in Python: def max_subarray(A): max_ending_here = max_so_far = 0 for x in A: max_ending_here = max(0, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 119 pascals traingle II","slug":"leetcode-119-pascals-traingle-II","date":"2016-12-03T06:31:44.000Z","updated":"2016-12-06T05:12:54.000Z","comments":true,"path":"2016/12/02/leetcode-119-pascals-traingle-II/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-119-pascals-traingle-II/","excerpt":"Question: 119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space?","text":"Question: 119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? Solution123456789101112131415161718192021//My solution, not O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; List&lt;Integer&gt; last = new ArrayList&lt;Integer&gt;(); last.add(1); if(rowIndex==0) return last; for(int j =1; j&lt;=rowIndex; j++)&#123; result = new ArrayList&lt;Integer&gt;(); result.add(1); for(int i=0;i&lt;last.size()-1;i++)&#123; result.add(last.get(i)+last.get(i+1)); &#125; result.add(1); last = result; &#125; return result; &#125;&#125; 1234567891011121314//O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; for(int i=0; i&lt;=rowIndex;i++)&#123; result.add(1); for(int j=i-1;j&gt;0;j--)&#123; result.set(j, result.get(j)+result.get(j-1)); &#125; &#125; return result; &#125;&#125; Thoughts思路： 从后往前算 in place replace","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 118 pascal's triangle","slug":"leetcode-118-pascal-s-triangle","date":"2016-12-03T05:35:44.000Z","updated":"2016-12-06T05:12:51.000Z","comments":true,"path":"2016/12/02/leetcode-118-pascal-s-triangle/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-118-pascal-s-triangle/","excerpt":"Question: 118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]","text":"Question: 118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Solution123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(numRows&lt;=0) return result; List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;(); first.add(1); result.add(first); for(int i=2;i&lt;=numRows;i++)&#123; List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; last = result.get(result.size()-1); current.add(1); for(int j=0;j&lt;last.size()-1;j++)&#123; current.add(last.get(j)+last.get(j+1)); &#125; current.add(1); result.add(current); &#125; return result; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 283 Move zeroes","slug":"leetcode-283-Move-zeroes","date":"2016-12-03T03:19:28.000Z","updated":"2016-12-06T05:13:25.000Z","comments":true,"path":"2016/12/02/leetcode-283-Move-zeroes/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-283-Move-zeroes/","excerpt":"Question: 283. Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations.","text":"Question: 283. Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. Solution1234567891011121314151617public class Solution &#123; public void moveZeroes(int[] nums) &#123; int i =0; int count =0; while(i&lt;nums.length)&#123; if(nums[i]!=0)&#123; nums[count]=nums[i]; count++; &#125; i++; &#125; while(count&lt;nums.length)&#123; nums[count]=0; count++; &#125; &#125;&#125; Thoughts思路：O(n)time O(1) space1.loop the array from the beginning, use a slow runner to keep tracking the current index, if it is none zero, put that in the current index place. otherwise, continue.2.put 0 to the remaining indexes.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 448 Find All Numbers Disappeared in an Array","slug":"leetcode-448-Find-All-Numbers-Disappeared-in-an-Array","date":"2016-12-02T06:47:49.000Z","updated":"2016-12-06T05:13:33.000Z","comments":true,"path":"2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","link":"","permalink":"http://xytian315.github.io/2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","excerpt":"","text":"Question: Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] Thoughts:思路：第一种简单解法O(n) space O(n) time1把数组中的所有数字放到一个set中2loop 从1到n, 如果数字i不在set中，即是答案disappeared number第二种优化解法O(1) space O(n)time1用index来标记是否数字出现于数组中， 如果数字在数组中，相应的index变成负数。nums[nums[i]-1] = -nums[nums[i]-1]2loop array, 如果数字是正数，说明这个数字没有出现在数组中，既是答案注：因为index是从0开始的，0到n-1, 而我们需要1到n, 所以纪录时要减1，最后结果要加1 Solution12345678910111213141516//O(n) space O(n) timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i =0; i&lt;nums.length;i++)&#123; set.add(nums[i]); &#125; for(int i=1; i&lt;= nums.length;i++)&#123; if(!set.contains(i))&#123; result.add(i); &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819// NO extra space solution O(1) space O(n)timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for(int i =0 ; i&lt;nums.length; i++)&#123; int value = Math.abs(nums[i])-1; if(nums[value]&gt;0)&#123; nums[value] = -nums[value]; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;0)&#123; result.add(i+1); &#125; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 26 Remove Duplicates from Sorted Array","slug":"leetcode-26","date":"2016-10-03T23:13:09.000Z","updated":"2016-12-07T04:32:28.000Z","comments":true,"path":"2016/10/03/leetcode-26/","link":"","permalink":"http://xytian315.github.io/2016/10/03/leetcode-26/","excerpt":"Question: 26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.","text":"Question: 26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. Thoughts:Two pointer techniquehttps://leetcode.com/articles/two-pointer-technique/two pointer: one fast runner, one slow runner Solution12345678910111213141516public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0 || nums.length == 1) return nums.length; int current = nums[0]; int count = 1; for(int i=1; i&lt; nums.length; i++) &#123; if(nums[i] != current) &#123; current = nums[i]; nums[count] = nums[i]; count++; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 189 Rotate Array","slug":"leetcode-189","date":"2016-09-12T19:06:08.000Z","updated":"2016-12-06T07:59:03.000Z","comments":true,"path":"2016/09/12/leetcode-189/","link":"","permalink":"http://xytian315.github.io/2016/09/12/leetcode-189/","excerpt":"","text":"Question: 189. Rotate ArrayRotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Solution12345678910111213141516171819//O(n) time o(1) spacepublic class Solution &#123; public void rotate(int[] nums, int k) &#123; if(k==0 || nums.length&lt;=1) return; k=k%nums.length; reverse(nums,0,nums.length-1); reverse(nums,0, k-1); reverse(nums,k, nums.length-1); &#125; public void reverse(int[] nums,int start, int end)&#123; while(start&lt;end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125; Thoughts Don’t forget to do k=k%nums.length; use a customized method to do common things: in this case reverse the array","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 11 Container With Most Water","slug":"leetcode-11","date":"2016-09-09T02:44:35.000Z","updated":"2016-12-06T05:12:48.000Z","comments":true,"path":"2016/09/08/leetcode-11/","link":"","permalink":"http://xytian315.github.io/2016/09/08/leetcode-11/","excerpt":"Question: 11. Container With Most Waterhttps://leetcode.com/problems/container-with-most-water/Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container.","text":"Question: 11. Container With Most Waterhttps://leetcode.com/problems/container-with-most-water/Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. Solution12","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"}]},{"title":"leetcode 169 Majority element","slug":"leetcode-169-Majority-element","date":"2016-09-01T06:12:06.000Z","updated":"2016-12-06T05:13:00.000Z","comments":true,"path":"2016/08/31/leetcode-169-Majority-element/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-169-Majority-element/","excerpt":"Question: 169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array.","text":"Question: 169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution1234567891011121314151617181920212223242526/** my solution sort**/public class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125;/** my solution map notes: remember to return immediately if the value is more n/2 times **/public class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums.length == 1) return nums[0]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt; nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; if(map.get(nums[i])&gt;=nums.length/2) return nums[i]; map.replace(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; return 0; &#125;&#125; Thoughtssort will be o(nlog) time; hashmap will be o(n) timethere are also another genius solution o(n) time o(1) space so called Moores’s Voting algorithmhttps://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution12345678910111213141516public class Solution &#123; public int majorityElement(int[] num) &#123; int major=num[0], count = 1; for(int i=1; i&lt;num.length;i++)&#123; if(count==0)&#123; count++; major=num[i]; &#125;else if(major==num[i])&#123; count++; &#125;else count--; &#125; return major; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 66 Plus one","slug":"leetcode-66-Plus-one","date":"2016-09-01T05:43:16.000Z","updated":"2016-12-06T05:13:49.000Z","comments":true,"path":"2016/08/31/leetcode-66-Plus-one/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-66-Plus-one/","excerpt":"Question: 66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list.","text":"Question: 66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. Solution1234567891011121314151617181920212223242526272829303132/** my solution */public class Solution &#123; public int[] plusOne(int[] digits) &#123; int i = digits.length-1; int carry = 0; digits[i] = digits[i]+1; while(i&gt;=0)&#123; digits[i] = digits[i]+carry; if(digits[i]&gt;=10)&#123; digits[i] = digits[i]-10; carry=1; &#125;else&#123; carry=0; &#125; i--; &#125; if(carry == 0)&#123; return digits; &#125;else&#123; int[] result = new int[digits.length+1]; result[0]=1; int index=0; int j=1; while(index&lt;digits.length)&#123; result[j] = digits[index]; j++; index++; &#125; return result; &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 7 Reverse Integer","slug":"leetcode-7-Reverse-Integer","date":"2016-08-10T04:34:29.000Z","updated":"2016-12-06T05:14:06.000Z","comments":true,"path":"2016/08/09/leetcode-7-Reverse-Integer/","link":"","permalink":"http://xytian315.github.io/2016/08/09/leetcode-7-Reverse-Integer/","excerpt":"Question: 7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321","text":"Question: 7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Solution12 Thoughts:Do not forget to think about overflow problem.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 6 ZigZag Conversion","slug":"leetcode-6","date":"2016-08-09T04:47:46.000Z","updated":"2016-12-06T05:13:40.000Z","comments":true,"path":"2016/08/08/leetcode-6/","link":"","permalink":"http://xytian315.github.io/2016/08/08/leetcode-6/","excerpt":"Question: 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/","text":"Question: 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/ Solution12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if (s == null || s.isEmpty() || numRows &lt;= 1 || numRows &gt;= s.length()) return s; int length = s.length(); int step = 2*(numRows-1); int count = 0; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; numRows; i++)&#123; int interval = step-2*i; for(int j = i; j &lt; length; j+=step)&#123; sb.append(s.charAt(j)); count++; if(interval &gt;0 &amp;&amp; interval != step &amp;&amp; count &lt; length &amp;&amp; (j+interval)&lt;length )&#123; sb.append(s.charAt(j+interval)); count++; &#125; &#125; &#125; return sb.toString(); &#125;&#125; Thoughts:I have no idea how to do this question at first, stucking for a whilehere is the solution https://kevinclcn.gitbooks.io/leetcodejava/content/006_zigzag_conversion.html","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 5 Longest Palindromic Substring","slug":"leetcode-5","date":"2016-08-05T14:00:47.000Z","updated":"2016-12-06T05:13:37.000Z","comments":true,"path":"2016/08/05/leetcode-5/","link":"","permalink":"http://xytian315.github.io/2016/08/05/leetcode-5/","excerpt":"Question: 5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.","text":"Question: 5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Solution12345678910111213141516171819202122232425262728/* * I only did the brute force solution O(n3) */ public class Solution &#123; public String longestPalindrome(String s) &#123; if(s.isEmpty() || s.length() == 1) return s; String result = \"\"; for(int i = 0; i &lt; s.length(); i++)&#123; for(int j = i+1; j&lt; s.length(); j++)&#123; if(isPalindrome(s, i, j) &amp;&amp; result.length() &lt; j-i+1)&#123; result = s.substring(i,j+1); &#125; &#125; &#125; int return result; &#125; public Boolean isPalindrome(String s, int i , int j)&#123; while(i&lt;j)&#123; if(s.charAt(i)!=s.charAt(j)) return false; i++; j--; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"leetcode 3 Longest Substring Without Repeating Characters","slug":"leetcode-3","date":"2016-08-04T23:44:34.000Z","updated":"2016-12-06T05:13:29.000Z","comments":true,"path":"2016/08/04/leetcode-3/","link":"","permalink":"http://xytian315.github.io/2016/08/04/leetcode-3/","excerpt":"Question: 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.","text":"Question: 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Solution1234567891011121314151617181920212223242526/**my solution without looking at the answers*/public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.isEmpty()) return 0; int result = 0; int start = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; if(map.containsKey(s.charAt(i))) &#123; if(result &lt; i - start ) &#123; result = i - start; &#125; if(map.get(s.charAt(i))+1 &gt; start)&#123; start = map.get(s.charAt(i)) + 1; &#125; &#125; map.put(s.charAt(i), i); &#125; if(result &lt; s.length()-start) &#123; result = s.length()-start; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"}]},{"title":"how to implement a singly LinkedList","slug":"how-to-implement-a-singly-LinkedList","date":"2016-08-02T23:02:36.000Z","updated":"2016-12-06T05:12:38.000Z","comments":true,"path":"2016/08/02/how-to-implement-a-singly-LinkedList/","link":"","permalink":"http://xytian315.github.io/2016/08/02/how-to-implement-a-singly-LinkedList/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SinglyLinkedList&lt;E&gt; &#123; /** * Nested node class */ private static class Node&lt;E&gt; &#123; private E element; private Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; public E getElement() &#123; return this.element; &#125; public Node&lt;E&gt; getNext() &#123; return this.next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; /** * end of nested node class */ private Node&lt;E&gt; head = null; private Node&lt;E&gt; tail = null; private Integer size = 0; public SinglyLinkedList() &#123; &#125; public Integer size() &#123; return this.size; &#125; public Boolean isEmpty() &#123; return this.size == 0; &#125; public E first() &#123; if(isEmpty()) return null; return head.getElement(); &#125; public E last() &#123; if(isEmpty()) return null; return tail.getElement(); &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newHead = new Node(e, head); this.head = newHead; size++; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node(e, null); if(isEmpty())&#123; head = newNode; &#125;else &#123; tail.setNext(newNode); this.tail = newNode; &#125; size++; &#125; public E removeFirst() &#123; if(isEmpty()) return null; E result = head.getElement(); this.head = head.getNext(); size--; return result; &#125;&#125; NotesNested class: when defining a class which is strongly affiliated with another class helps to increase encapsulation and avoid name conflicts Static means its value/method is associated with the class itself, rather than with each individual instance of the class.That means it is not invoked on a particular instance of the class using traditional dot notation.Instead, it is typically using the name of the class as a qualifier. useful for providing utility behaviors related to a class that need not rely on the state of any particular instance of the class.","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 2 Add Two Numbers","slug":"leetcode-2-Add-two-numbers","date":"2016-07-20T06:34:59.000Z","updated":"2016-12-06T05:13:09.000Z","comments":true,"path":"2016/07/19/leetcode-2-Add-two-numbers/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-2-Add-two-numbers/","excerpt":"Question: 2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8","text":"Question: 2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ /** Wrote the following solution without seeing other people's solutions **/public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode tail = null; int count = 0; while(l1 != null || l2 != null) &#123; if(l1 != null)&#123; count += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; count += l2.val; l2 = l2.next; &#125; ListNode ln = new ListNode(count%10); if(head == null) &#123; head = ln; tail = ln; &#125;else &#123; tail.next = ln; tail=ln; &#125; count = count/10; &#125; if(count&gt;0) &#123; tail.next= new ListNode(count); &#125; return head; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]}]}