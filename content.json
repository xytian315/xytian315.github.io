{"meta":{"title":"Kristy's blog","subtitle":null,"description":null,"author":"Kristy Tian","url":"http://xytian315.github.io"},"pages":[{"title":"tags","date":"2016-12-06T03:55:51.000Z","updated":"2016-12-06T03:55:51.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://xytian315.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"All tags","date":"2014-12-22T20:39:04.000Z","updated":"2016-12-06T04:36:05.000Z","comments":true,"path":"tags/index.html","permalink":"http://xytian315.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-09-09T02:28:40.000Z","updated":"2016-09-09T02:30:03.000Z","comments":true,"path":"about/index.html","permalink":"http://xytian315.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-06T04:58:03.000Z","updated":"2016-12-06T04:58:03.000Z","comments":true,"path":"categories/index-1.html","permalink":"http://xytian315.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"All categories","date":"2014-12-22T20:39:04.000Z","updated":"2016-12-06T05:01:28.000Z","comments":true,"path":"categories/index.html","permalink":"http://xytian315.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 167 Two Sum II - Input array is sorted","slug":"leetcode-167-Two-Sum-II-Input-array-is-sorted","date":"2017-04-26T05:05:54.000Z","updated":"2017-04-26T05:50:02.000Z","comments":true,"path":"2017/04/25/leetcode-167-Two-Sum-II-Input-array-is-sorted/","link":"","permalink":"http://xytian315.github.io/2017/04/25/leetcode-167-Two-Sum-II-Input-array-is-sorted/","excerpt":"","text":"Question 167. Two Sum II - Input array is sortedGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 Solution123456789101112131415161718192021222324252627282930313233//two pointer solution//my solution not good O(n2)public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; for(int slow=0; slow&lt;numbers.length-1;slow++)&#123; for(int fast=slow+1;fast&lt;=numbers.length-1; fast++)&#123; if(numbers[fast]==target-numbers[slow])&#123; return new int[]&#123;slow+1,fast+1&#125;; &#125;else if(numbers[fast]&gt; target-numbers[slow])&#123; break; &#125; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125;//better solution O(n)public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int slow = 0; int fast = numbers.length-1; while(slow&lt;fast)&#123; if(numbers[slow] + numbers[fast] == target)&#123; return new int[]&#123;slow+1,fast+1&#125;; &#125;else if(numbers[slow] + numbers[fast] &gt; target)&#123; fast--; &#125;else&#123; slow++; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"binary search","slug":"binary-search","permalink":"http://xytian315.github.io/tags/binary-search/"}]},{"title":"leetcode 69 sqrt(x)","slug":"leetcode-69-sqrt-x","date":"2017-02-05T05:09:03.000Z","updated":"2017-02-05T05:57:00.000Z","comments":true,"path":"2017/02/04/leetcode-69-sqrt-x/","link":"","permalink":"http://xytian315.github.io/2017/02/04/leetcode-69-sqrt-x/","excerpt":"","text":"Question:Implement int sqrt(int x). Compute and return the square root of x. Solution//discuss answer public class Solution { public int mySqrt(int x) { if (x == 0) return 0; int left = 1, right = x; while (true) { int mid = left + (right - left)/2; if (mid &gt; x/mid) { right = mid - 1; } else { if (mid + 1 &gt; x/(mid + 1)) return mid; left = mid + 1; } } } } Thoughtsbinary search","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"},{"name":"binary search","slug":"binary-search","permalink":"http://xytian315.github.io/tags/binary-search/"}]},{"title":"leetcode 67 Add Binary","slug":"leetcode-67-Add-Binary","date":"2017-02-03T07:15:14.000Z","updated":"2017-02-03T19:43:34.000Z","comments":true,"path":"2017/02/02/leetcode-67-Add-Binary/","link":"","permalink":"http://xytian315.github.io/2017/02/02/leetcode-67-Add-Binary/","excerpt":"","text":"Question: 67. Add BinaryGiven two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”. Solution1234567891011121314151617181920public class Solution &#123; public String addBinary(String a, String b) &#123; int i=a.length()-1; int j=b.length()-1; int carry = 0; StringBuilder sb= new StringBuilder(); while(i&gt;=0 || j&gt;=0)&#123; int temp=carry; if(i&gt;=0) temp+=a.charAt(i--)-'0'; if(j&gt;=0) temp+=b.charAt(j--)-'0'; sb.append(temp%2); carry=temp/2; &#125; if(carry!=0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; Notesuse StringBuilder;StringBuilder has reverse() method;there could be 3 use ()%2 and ()/2 to calculate the value and carry","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 13 Roman to Integer","slug":"leetcode-13-Roman-to-Integer","date":"2017-02-01T06:37:53.000Z","updated":"2017-02-01T07:09:29.000Z","comments":true,"path":"2017/01/31/leetcode-13-Roman-to-Integer/","link":"","permalink":"http://xytian315.github.io/2017/01/31/leetcode-13-Roman-to-Integer/","excerpt":"","text":"Question: 13. Roman to IntegerGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//my first time solutionpublic class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result=0; int index =0; while(index&lt;=s.length()-2)&#123; Character c1 = s.charAt(index); Character c2 = s.charAt(index+1); int value1 = map.get(c1); int value2 = map.get(c2); if(value1&gt;=value2)&#123; result+=value1; index++; &#125;else&#123; result+=value2-value1; index+=2; &#125; &#125; if(index==s.length()-1) result+=map.get(s.charAt(index)); return result; &#125;&#125;//refactor a little bit, MMXIV = M+M+X-I+V I was thinking \"M+M+X+(V-I)\" :(public class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result=0; int index =0; while(index&lt;=s.length()-2)&#123; Character c1 = s.charAt(index); Character c2 = s.charAt(index+1); int value1 = map.get(c1); int value2 = map.get(c2); if(value1&gt;=value2)&#123; result+=value1; &#125;else&#123; result-=value1; &#125; index++; &#125; result+=map.get(s.charAt(index)); return result; &#125;&#125; Thoughtsbesides map, we could also put into an array","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 9 Palindrome Number","slug":"leetcode-9-Palindrome-Number","date":"2017-01-31T08:01:38.000Z","updated":"2017-01-31T08:18:54.000Z","comments":true,"path":"2017/01/31/leetcode-9-Palindrome-Number/","link":"","permalink":"http://xytian315.github.io/2017/01/31/leetcode-9-Palindrome-Number/","excerpt":"","text":"Question: Palindrome NumberDetermine whether an integer is a palindrome. Do this without extra space. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Solution//my solution public class Solution { public boolean isPalindrome(int x) { if(x&lt;0) return false; //find the length int temp = x; int length=0; while(temp!=0){ temp=temp/10; length++; } // calculate the middle number int middle = length%2 !=0 ? length/2+1 : length/2; //first half int front=x; for(int i =1; i&lt;=middle;i++){ front=front/10; } //second half and reverse int value=x; int back=0; for(int i=1;i&lt;=length-middle;i++){ int tail = value%10; back=back*10+tail; value=value/10; } return front==back; } } //smarter solution public class Solution { public boolean isPalindrome(int x) { if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int rev = 0; while (x&gt;rev){ rev = rev*10 + x%10; x = x/10; } return (x==rev || x==rev/10); } } NotesNegative number is not palindrome.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 237 Delete Node in a Linked List","slug":"leetcode-237-Delete-Node-in-a-Linked-List","date":"2017-01-30T02:11:13.000Z","updated":"2017-01-30T02:12:14.000Z","comments":true,"path":"2017/01/29/leetcode-237-Delete-Node-in-a-Linked-List/","link":"","permalink":"http://xytian315.github.io/2017/01/29/leetcode-237-Delete-Node-in-a-Linked-List/","excerpt":"","text":"Question: 237. Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Solution123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void deleteNode(ListNode node) &#123; node.val=node.next.val; node.next=node.next.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 234 Palindrome Linked List","slug":"leetcode-234-Palindrome-Linked-List","date":"2017-01-28T21:44:51.000Z","updated":"2017-01-29T06:54:18.000Z","comments":true,"path":"2017/01/28/leetcode-234-Palindrome-Linked-List/","link":"","permalink":"http://xytian315.github.io/2017/01/28/leetcode-234-Palindrome-Linked-List/","excerpt":"","text":"Question: 234. Palindrome Linked ListGiven a singly linked list, determine if it is a palindrome.Follow up:Could you do it in O(n) time and O(1) space? Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; //calculate the length of the node int length=0; ListNode temp = head; while(temp!=null)&#123; temp=temp.next; length++; &#125; //find the middle of the ListNode ListNode middle=head; for(int i =0; i&lt;=length/2-1;i++)&#123; middle=middle.next; &#125; if(length%2!=0) middle=middle.next; //reverse the second half of the listNode ListNode newMiddle=reverse(middle); //compare first half and reversed harlf of the listNode while(head!=null &amp;&amp; newMiddle!=null)&#123; if(head.val!=newMiddle.val) return false; head=head.next; newMiddle=newMiddle.next; &#125; return true; &#125; ListNode reverse(ListNode node)&#123; if(node==null || node.next==null) return node; ListNode temp = node.next; ListNode newHead=reverse(temp); temp.next=node; node.next=null; return newHead; &#125;&#125;//refactor a little bit, we don't need to get the length to find the middle of the ListNode,//we can just use the two pointers to find the middle of the ListNode;public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head==null||head.next==null) return true; //find the middle of the ListNode; //use two pointers one move one step, the other one move two steps ListNode slow = head; ListNode fast = head; while(fast!=null &amp;&amp; fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; &#125; //odd numbers move one more into the other half if(fast!=null) slow=slow.next; //reverse the second half of the listNode ListNode newMiddle=reverse(slow); //compare first half and reversed harlf of the listNode while(head!=null &amp;&amp; newMiddle!=null)&#123; if(head.val!=newMiddle.val) return false; head=head.next; newMiddle=newMiddle.next; &#125; return true; &#125; ListNode reverse(ListNode node)&#123; if(node==null || node.next==null) return node; ListNode temp = node.next; ListNode newHead=reverse(temp); temp.next=node; node.next=null; return newHead; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 206 Reverse Linked List","slug":"leetcode-206-Reverse-Linked-List","date":"2017-01-28T05:44:33.000Z","updated":"2017-01-28T06:41:50.000Z","comments":true,"path":"2017/01/27/leetcode-206-Reverse-Linked-List/","link":"","permalink":"http://xytian315.github.io/2017/01/27/leetcode-206-Reverse-Linked-List/","excerpt":"","text":"Question: 206. Reverse Linked ListReverse a singly linked list.recursive and iterative Solution/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ //my passed recursive solution public class Solution { public ListNode reverseList(ListNode head) { if(head==null|| head.next==null) return head; ListNode node = head.next; if(node.next!=null){ node=reverseList(node); } ListNode node2=node; while(node2.next!=null){ node2=node2.next; } node2.next=head; head.next=null; return node; } } //cleaner recursive solution public class Solution { public ListNode reverseList(ListNode head) { if(head==null|| head.next==null) return head; ListNode nodeNext = head.next; ListNode newHead = reverseList(nodeNext); nodeNext.next = head; head.next = null; return newHead; } } //iterative solution public class Solution { public ListNode reverseList(ListNode head) { if(head==null|| head.next==null) return head; ListNode newHead = null; while(head!=null){ ListNode nodeNext = head.next; head.next=newHead; newHead=head; head=nodeNext; } return newHead; } } Notesrecursive and iterative","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 203 Remove Linked List Elements","slug":"leetcode-203-Remove-Linked-List-Elements","date":"2017-01-28T05:23:25.000Z","updated":"2017-01-28T05:39:57.000Z","comments":true,"path":"2017/01/27/leetcode-203-Remove-Linked-List-Elements/","link":"","permalink":"http://xytian315.github.io/2017/01/27/leetcode-203-Remove-Linked-List-Elements/","excerpt":"","text":"Question: 203. Remove Linked List ElementsRemove all elements from a linked list of integers that have value val. ExampleGiven: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 Solution12345678910111213141516171819202122232425262728//my one time pass solution haha:)/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head==null) return head; if(head.val==val) return removeElements(head.next,val); head.next = removeElements(head.next,val); return head; &#125;&#125;//we can refactor a little bitpublic class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) return null; head.next = removeElements(head.next, val); return head.val == val ? head.next : head; &#125;&#125; Notesrecursive","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 160 Intersection of Two Linked Lists","slug":"leetcode-160-Intersection-of-Two-Linked-Lists","date":"2017-01-27T05:23:55.000Z","updated":"2017-01-27T06:28:36.000Z","comments":true,"path":"2017/01/26/leetcode-160-Intersection-of-Two-Linked-Lists/","link":"","permalink":"http://xytian315.github.io/2017/01/26/leetcode-160-Intersection-of-Two-Linked-Lists/","excerpt":"","text":"Question: 160. Intersection of Two Linked ListsWrite a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3begin to intersect at node c1. Notes:If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory. Solution12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; *///best solutionpublic class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; ListNode a=headA; ListNode b=headB; while(a!=b)&#123; a= a==null ? headB : a.next; b= b==null ? headA : b.next; &#125; return a; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435//another solution easy to understand////1, Get the length of the two lists.//2, Align them to the same start point.//3, Move them together until finding the intersection point, or the end nullpublic class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null) return null; int lengthA=length(headA); int lengthB=length(headB); while(lengthA&gt;lengthB)&#123; headA=headA.next; lengthA--; &#125; while(lengthA&lt;lengthB)&#123; headB=headB.next; lengthB--; &#125; while(headA!=headB)&#123; headA=headA.next; headB=headB.next; &#125; return headA; &#125; public int length(ListNode node)&#123; int result=1; while(node.next!=null)&#123; node=node.next; result++; &#125; return result; &#125;&#125; Notes:https://discuss.leetcode.com/topic/28067/java-solution-without-knowing-the-difference-in-lenWe can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null the two iterations will both run for listA.length + listB.length and will reach the intersection point at the same time after switching the pointer.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"Leetcode 141 Linked List Cycle","slug":"Leetcode-141-Linked-List-Cycle","date":"2017-01-26T05:57:17.000Z","updated":"2017-01-26T06:26:39.000Z","comments":true,"path":"2017/01/25/Leetcode-141-Linked-List-Cycle/","link":"","permalink":"http://xytian315.github.io/2017/01/25/Leetcode-141-Linked-List-Cycle/","excerpt":"","text":"Question: 141. Linked List CycleGiven a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? Solution1234567891011121314151617181920212223242526272829303132333435363738394041//my first time solution/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null) return false; Set&lt;ListNode&gt; set = new HashSet&lt;ListNode&gt;(); while(head.next!=null)&#123; if(!set.add(head))&#123; return true; &#125; head=head.next; &#125; return false; &#125;&#125;//better solution!public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null || head.next==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null&amp;&amp; runner.next.next!=null)&#123; walker = walker.next; runner = runner.next.next; if(walker == runner) return true; &#125; return false; &#125;&#125; Notes:Floyd’s cycle-finding algorithm, also know as tortoise and hare algorithm. The idea is to have two pointers to the list and move them at different speeds. Move one forward by 1 node and the other by 2 nodes. If the linked list has a loop they will definitely meet.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"}]},{"title":"leetcode 83 Removed duplicates from sorted list","slug":"leetcode-83-Removed-duplicates-from-sorted-list","date":"2017-01-25T02:44:58.000Z","updated":"2017-01-25T05:48:25.000Z","comments":true,"path":"2017/01/24/leetcode-83-Removed-duplicates-from-sorted-list/","link":"","permalink":"http://xytian315.github.io/2017/01/24/leetcode-83-Removed-duplicates-from-sorted-list/","excerpt":"","text":"Question: 83. Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. Solution//my first time solution /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next==null) return head; ListNode slow = head; ListNode fast = head.next; int temp=slow.val; while(slow!=null&amp;&amp;fast!=null){ while(fast.val==temp&amp;&amp;fast.next!=null) fast=fast.next; if(fast.val==temp){ slow.next=null; break; } slow.next=fast; slow=slow.next; fast=fast.next; temp=slow.val; } return head; } } //better solution public class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next==null) return head; head.next=deleteDuplicates(head.next); return head.val==head.next.val ? head.next : head; } } NotesRecursive","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 24 Swap Nodes in Pairs","slug":"leetcode-24-Swap-Nodes-in-Pairs","date":"2017-01-24T04:02:49.000Z","updated":"2017-01-24T04:06:45.000Z","comments":true,"path":"2017/01/23/leetcode-24-Swap-Nodes-in-Pairs/","link":"","permalink":"http://xytian315.github.io/2017/01/23/leetcode-24-Swap-Nodes-in-Pairs/","excerpt":"","text":"Question: 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//my first time solution/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode current = head; if(current == null || current.next==null)&#123; return current; &#125;else&#123; ListNode temp1=current; ListNode temp2=current.next; ListNode temp3; if(temp2.next!=null)&#123; temp3=temp2.next; &#125; else&#123; temp3=null; &#125; current=temp2; temp2.next=temp1; if(temp3==null)&#123; temp1.next=null; &#125;else&#123; temp1.next=swapPairs(temp3); &#125; &#125; return current; &#125;&#125;//better solutionpublic class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next==null)&#123; return head; &#125; ListNode temp = head.next; head.next=swapPairs(head.next.next); temp.next=head; return temp; &#125;&#125; Notesrecursive","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 21 Merged two sortd list","slug":"leetcode-21-Merged-two-sortd-list","date":"2017-01-23T05:06:48.000Z","updated":"2017-01-23T06:36:37.000Z","comments":true,"path":"2017/01/22/leetcode-21-Merged-two-sortd-list/","link":"","permalink":"http://xytian315.github.io/2017/01/22/leetcode-21-Merged-two-sortd-list/","excerpt":"","text":"Question: 21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Solution/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val){ l1.next=mergeTwoLists(l1.next, l2); return l1; }else{ l2.next=mergeTwoLists(l2.next,l1); return l2; } } } NotesRecursive","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 19 Remove nth node from end of list","slug":"leetcode-19-Remove-nth-node-from-end-of-list","date":"2017-01-22T02:57:37.000Z","updated":"2017-01-22T03:48:47.000Z","comments":true,"path":"2017/01/21/leetcode-19-Remove-nth-node-from-end-of-list/","link":"","permalink":"http://xytian315.github.io/2017/01/21/leetcode-19-Remove-nth-node-from-end-of-list/","excerpt":"","text":"Question: 19. Remove Nth Node From End of ListGiven a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. Solution123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; //use two pointers one slow, one fast ListNode start = new ListNode(0); ListNode slow = start; ListNode fast = start; slow.next = head; //make the gap between slow and fast to be n for(int i=1; i&lt;=n;i++)&#123; fast = fast.next; &#125; //move the slow and fast pointer until the end of the node, keep the same distance while(fast.next!=null)&#123; fast = fast.next; slow = slow.next; &#125; //slow's next one is the one we want to remove slow.next = slow.next.next; //return the orginal head return start.next; &#125;&#125; Noteshttps://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-passMove one pointer fast –&gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node. Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"}]},{"title":"leetcode 438 Find all anagrams in a string","slug":"leetcode-438-Find-all-anagrams-in-a-string","date":"2016-12-13T08:11:15.000Z","updated":"2016-12-13T08:14:10.000Z","comments":true,"path":"2016/12/13/leetcode-438-Find-all-anagrams-in-a-string/","link":"","permalink":"http://xytian315.github.io/2016/12/13/leetcode-438-Find-all-anagrams-in-a-string/","excerpt":"Question: 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input:s: “cbaebabacd” p: “abc” Output:[0, 6] Explanation:The substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”.Example 2: Input:s: “abab” p: “ab” Output:[0, 1, 2] Explanation:The substring with start index = 0 is “ab”, which is an anagram of “ab”.The substring with start index = 1 is “ba”, which is an anagram of “ab”.The substring with start index = 2 is “ab”, which is an anagram of “ab”.","text":"Question: 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input:s: “cbaebabacd” p: “abc” Output:[0, 6] Explanation:The substring with start index = 0 is “cba”, which is an anagram of “abc”.The substring with start index = 6 is “bac”, which is an anagram of “abc”.Example 2: Input:s: “abab” p: “ab” Output:[0, 1, 2] Explanation:The substring with start index = 0 is “ab”, which is an anagram of “ab”.The substring with start index = 1 is “ba”, which is an anagram of “ab”.The substring with start index = 2 is “ab”, which is an anagram of “ab”. Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0 || p == null || p.length() == 0) return list; int[] hash = new int[256]; //character hash //record each character in p to hash for (char c : p.toCharArray()) &#123; hash[c]++; &#125; //two points, initialize count to p's length int left = 0, right = 0, count = p.length(); while (right &lt; s.length()) &#123; //move right everytime, if the character exists in p's hash, decrease the count //current hash value &gt;= 1 means the character is existing in p if (hash[s.charAt(right)] &gt;= 1) &#123; count--; &#125; hash[s.charAt(right)]--; right++; //when the count is down to 0, means we found the right anagram //then add window's left to result list if (count == 0) &#123; list.add(left); &#125; //if we find the window's size equals to p, then we have to move left (narrow the window) to find the new match window //++ to reset the hash because we kicked out the left //only increase the count if the character is in p //the count &gt;= 0 indicate it was original in the hash, cuz it won't go below 0 if (right - left == p.length() ) &#123; if (hash[s.charAt(left)] &gt;= 0) &#123; count++; &#125; hash[s.charAt(left)]++; left++; &#125; &#125; return list; &#125;&#125; Thoughtshttps://discuss.leetcode.com/topic/64434/shortest-concise-java-o-n-sliding-window-solution/4","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 409 Longest Palindrome","slug":"leetcode-409-Longest-Palindrome","date":"2016-12-12T05:24:46.000Z","updated":"2016-12-12T05:28:56.000Z","comments":true,"path":"2016/12/11/leetcode-409-Longest-Palindrome/","link":"","permalink":"http://xytian315.github.io/2016/12/11/leetcode-409-Longest-Palindrome/","excerpt":"Question: 409. Longest PalindromeGiven a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010.","text":"Question: 409. Longest PalindromeGiven a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. Solution1234567891011121314151617public class Solution &#123; public int longestPalindrome(String s) &#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int count=0; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(set.contains(c))&#123; set.remove(c); count+=2; &#125;else&#123; set.add(c); &#125; &#125; if(!set.isEmpty()) count++; return count; &#125;&#125; Thoughts just count the number of same pairs, then this can be used to put in the different direction to consist of palindrome. Then if there exist more chars, we can put one in the middle","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"389 find the difference","slug":"leetcode-389-find-the-difference","date":"2016-12-11T06:39:42.000Z","updated":"2016-12-11T06:49:17.000Z","comments":true,"path":"2016/12/10/leetcode-389-find-the-difference/","link":"","permalink":"http://xytian315.github.io/2016/12/10/leetcode-389-find-the-difference/","excerpt":"Question: 389. Find the DifferenceGiven two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input:s = “abcd”t = “abcde” Output:e Explanation:‘e’ is the letter that was added.","text":"Question: 389. Find the DifferenceGiven two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input:s = “abcd”t = “abcde” Output:e Explanation:‘e’ is the letter that was added. Solution12345678910111213141516171819202122232425262728293031323334353637//my solutionpublic class Solution &#123; public char findTheDifference(String s, String t) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char c =s.charAt(i); if(map.containsKey(c))&#123; map.put(c, map.get(c)+1); &#125;else&#123; map.put(c,1); &#125; &#125; for(int i=0;i&lt;t.length();i++)&#123; char c=t.charAt(i); if(!map.containsKey(c))&#123; return c; &#125;else&#123; if(map.get(c)&lt;=0) return c; map.put(c, map.get(c)-1); &#125; &#125; return t.charAt(0); &#125;&#125;//better solution in discussionpublic class Solution &#123; public char findTheDifference(String s, String t) &#123; // Initialize variables to store sum of ASCII codes for // each string int charCodeS = 0, charCodeT = 0; // Iterate through both strings and char codes for (int i = 0; i &lt; s.length(); ++i) charCodeS += (int)s.charAt(i); for (int i = 0; i &lt; t.length(); ++i) charCodeT += (int)t.charAt(i); // Return the difference between 2 strings as char return (char)(charCodeT - charCodeS); &#125;&#125; Thoughts1.just use the map to record the characters and count in the first s; loop the second s, descrease the correspoing value(count) by 1. if it doesn’t exist in the map it is the result; also if the count reach the 0, it is the result too. use ASCII code to represent the character in the string","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"350 Intersection or two arrays II","slug":"leetcode-350-Intersection-or-two-arrays-II","date":"2016-12-11T06:17:59.000Z","updated":"2016-12-11T06:28:28.000Z","comments":true,"path":"2016/12/10/leetcode-350-Intersection-or-two-arrays-II/","link":"","permalink":"http://xytian315.github.io/2016/12/10/leetcode-350-Intersection-or-two-arrays-II/","excerpt":"Question: 350. Intersection of Two Arrays IIGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?","text":"Question: 350. Intersection of Two Arrays IIGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//my solution //time O(nlogn) (sort)public class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int i=0; int j=0; ArrayList&lt;Integer&gt; array=new ArrayList&lt;Integer&gt;(); while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123; if(nums1[i]&lt;nums2[j])&#123; i++; &#125; else if(nums1[i]&gt;nums2[j])&#123; j++; &#125; else&#123; array.add(nums1[i]); i++; j++; &#125; &#125; int[] result = new int[array.size()]; int index =0; for(int e: array)&#123; result[index]=e; index++; &#125; return result; &#125;&#125;//another solution using hashmap//time O(n) spaceO(n)public class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); ArrayList&lt;Integer&gt; array=new ArrayList&lt;Integer&gt;(); for(int e: nums1)&#123; if(map.containsKey(e))&#123; map.put(e, map.get(e)+1); &#125;else&#123; map.put(e, 1); &#125; &#125; for(int e: nums2)&#123; if(map.containsKey(e) &amp;&amp; map.get(e)&gt;0)&#123; array.add(e); map.put(e, map.get(e)-1); &#125; &#125; int[] result = new int[array.size()]; int index =0; for(int e: array)&#123; result[index]=e; index++; &#125; return result; &#125;&#125; Thoughts1.sort two array, used two pointers to compare each number. based comparison,increment the corresponding index.2.use hashmap to tracking all the numbers and count. loop the second array, if it contains the key and value&gt;0, put it into result, also decrease the count(value); follow up answer from discussionWhat if elements of nums2 are stored on disk, and the memory islimited such that you cannot load all elements into the memory atonce?If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections. If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"},{"name":"sort","slug":"sort","permalink":"http://xytian315.github.io/tags/sort/"}]},{"title":"leetcode 349 Intersection of two arrays","slug":"leetcode-349-Intersection-of-two-arrays","date":"2016-12-11T06:05:28.000Z","updated":"2016-12-11T06:09:47.000Z","comments":true,"path":"2016/12/10/leetcode-349-Intersection-of-two-arrays/","link":"","permalink":"http://xytian315.github.io/2016/12/10/leetcode-349-Intersection-of-two-arrays/","excerpt":"Question: 349. Intersection of Two ArraysGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order.","text":"Question: 349. Intersection of Two ArraysGiven two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//my solutionpublic class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int ele: nums1)&#123; set1.add(ele); &#125; for(int ele: nums2)&#123; set2.add(ele); &#125; for(int ele:set1)&#123; if(!set2.add(ele))&#123; set.add(ele); &#125; &#125; int[] result= new int[set.size()]; int index=0; for(int element:set)&#123; result[index]=element; index++; &#125; return result; &#125;&#125;//actually you can use only two sets// time O(n) space O(n)public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int ele: nums1)&#123; set1.add(ele); &#125; for(int ele:nums2)&#123; if(set1.contains(ele))&#123; set.add(ele); &#125; &#125; int[] result= new int[set.size()]; int index=0; for(int element:set)&#123; result[index]=element; index++; &#125; return result; &#125;&#125; Thoughtsuse one set to record all the unique numbers. Looping the second array, if the set contain that number, put it into intersection set","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 290 word pattern","slug":"leetcode-290-word-pattern","date":"2016-12-10T07:37:22.000Z","updated":"2016-12-10T07:58:37.000Z","comments":true,"path":"2016/12/09/leetcode-290-word-pattern/","link":"","permalink":"http://xytian315.github.io/2016/12/09/leetcode-290-word-pattern/","excerpt":"Question: 290. Word PatternGiven a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples:pattern = “abba”, str = “dog cat cat dog” should return true.pattern = “abba”, str = “dog cat cat fish” should return false.pattern = “aaaa”, str = “dog cat cat dog” should return false.pattern = “abba”, str = “dog dog dog dog” should return false.Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.","text":"Question: 290. Word PatternGiven a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples:pattern = “abba”, str = “dog cat cat dog” should return true.pattern = “abba”, str = “dog cat cat fish” should return false.pattern = “aaaa”, str = “dog cat cat dog” should return false.pattern = “abba”, str = “dog dog dog dog” should return false.Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243// the question is exactly same as isomorphic stringpublic class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; String[] strings =str.split(\" \"); if(pattern.length()!=strings.length) return false; Map&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;(); for(int i=0;i&lt;pattern.length();i++)&#123; //has seen the key(char) before the value must be the same if(map.containsKey(pattern.charAt(i)))&#123; if(map.get(pattern.charAt(i)).compareTo(strings[i])!=0) return false; &#125;else&#123; //same value can not be mapping to different keys if(map.containsValue(strings[i])) return false; map.put(pattern.charAt(i), strings[i]); &#125; &#125; return true; &#125;&#125;//my Solutionpublic class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; String[] strings =str.split(\" \"); if(pattern.length()!=strings.length) return false; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int last=0; for(int i=0;i&lt;pattern.length();i++)&#123; if(map.containsKey(pattern.charAt(i)))&#123; int index = map.get(pattern.charAt(i)); if(strings[i].compareTo(strings[index])!=0) return false; &#125;else&#123; if(!map.isEmpty() &amp;&amp; strings[i].compareTo(strings[last])==0) return false; map.put(pattern.charAt(i),i); last =i; &#125; &#125; return true; &#125;&#125; ThoughtsThis question is exactly same as isomorphic stringin isomorphic string is char mapping to char, here is char mapping to string","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 299 Bulls and Cows","slug":"leetcode-299-Bulls-and-Cows","date":"2016-12-09T06:42:54.000Z","updated":"2016-12-10T07:37:44.000Z","comments":true,"path":"2016/12/08/leetcode-299-Bulls-and-Cows/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-299-Bulls-and-Cows/","excerpt":"Question: 299. Bulls and CowsYou are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.","text":"Question: 299. Bulls and CowsYou are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//solution from discussionpublic class Solution &#123; public String getHint(String secret, String guess) &#123; int[] numbers = new int[10]; int bulls=0; int cows=0; for(int i=0;i&lt;secret.length();i++)&#123; int s = Character.getNumericValue(secret.charAt(i)); int g = Character.getNumericValue(guess.charAt(i)); if(s==g)&#123; bulls++; &#125;else&#123; if(numbers[s]&lt;0) cows++; if(numbers[g]&gt;0) cows++; numbers[s]++; numbers[g]--; &#125; &#125; return bulls+\"A\"+cows+\"B\"; &#125;&#125;//my complicated solutionpublic class Solution &#123; public String getHint(String secret, String guess) &#123; int bulls =0; int cows =0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;secret.length();i++)&#123; if(secret.charAt(i)==guess.charAt(i))&#123; bulls++; set.add(i); &#125; else &#123; Character s = secret.charAt(i); if (map.containsKey(s)) &#123; map.put(s, map.get(s) + 1); &#125; else &#123; map.put(s, 1); &#125; &#125; &#125; for(int i=0;i&lt;guess.length();i++)&#123; Character g = guess.charAt(i); if(map.containsKey(g)&amp;&amp;!set.contains(i))&#123; map.put(g,map.get(g)-1); if(map.get(g) &gt;=0) cows++; &#125; &#125; StringBuilder sb=new StringBuilder(); sb.append(bulls); sb.append(\"A\"); sb.append(cows); sb.append(\"B\"); return sb.toString(); &#125;&#125; ThoughtsThe idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 242 Valid Anagram","slug":"leetcode-242-Valid-Anagram","date":"2016-12-09T05:35:06.000Z","updated":"2016-12-09T07:13:34.000Z","comments":true,"path":"2016/12/08/leetcode-242-Valid-Anagram/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-242-Valid-Anagram/","excerpt":"Question: 242. Valid AnagramGiven two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case?","text":"Question: 242. Valid AnagramGiven two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//use arraypublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; int[] chars= new int[26]; for(int i=0;i&lt;s.length();i++)&#123; chars[s.charAt(i)-'a']++; chars[t.charAt(i)-'a']--; &#125; for(int element:chars)&#123; if(element!=0)&#123; return false; &#125; &#125; return true; &#125;&#125;//use mappublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; map.put(s.charAt(i), map.get(s.charAt(i))+1); &#125;else&#123; map.put(s.charAt(i),1); &#125; &#125; for(int i=0;i&lt;t.length();i++)&#123; if(map.containsKey(t.charAt(i)) &amp;&amp; (map.get(t.charAt(i))&gt;0)) &#123; map.put(t.charAt(i),map.get(t.charAt(i))-1); &#125;else&#123; return false; &#125; &#125; return true; &#125;&#125;//my solution//the strings only include 26 english letter, I don't need to use ASCII 256 lengthpublic class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; int[] chars = new int[256]; int[] chart = new int[256]; for(int i=0;i&lt;256;i++)&#123; chars[i]=chart[i]=0; &#125; for(int i=0;i&lt;s.length();i++)&#123; chars[s.charAt(i)]=chars[s.charAt(i)]+1; chart[t.charAt(i)]=chart[t.charAt(i)]+1; &#125; for(int i=0;i&lt;256;i++)&#123; if(chars[i]!=chart[i]) return false; &#125; return true; &#125;&#125; ThoughtsWe can use a map or an array to keep tracking,the total number for the same character should be the same. the difference of the number should be 0.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 205 Isomorphic strings","slug":"leetcode-205-Isomorphic-strings","date":"2016-12-09T03:56:50.000Z","updated":"2016-12-09T04:13:12.000Z","comments":true,"path":"2016/12/08/leetcode-205-Isomorphic-strings/","link":"","permalink":"http://xytian315.github.io/2016/12/08/leetcode-205-Isomorphic-strings/","excerpt":"Question: 205. Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.","text":"Question: 205. Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Solution1234567891011121314151617public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); for(int i=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; if(map.get(s.charAt(i))!=t.charAt(i)) return false; &#125;else&#123; if(map.containsValue((t.charAt(i)))) return false; map.put(s.charAt(i), t.charAt(i)); &#125; &#125; return true; &#125;&#125; ThoughtsKeywords: No two characters may map to the same character.define a map which tracks the char-char mappings. If a value is already mapped, it can not be mapped again.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 204 count primes","slug":"leetcode-204-count-primes","date":"2016-12-08T03:13:02.000Z","updated":"2016-12-08T03:18:50.000Z","comments":true,"path":"2016/12/07/leetcode-204-count-primes/","link":"","permalink":"http://xytian315.github.io/2016/12/07/leetcode-204-count-primes/","excerpt":"Question: 204. Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n.","text":"Question: 204. Count PrimesDescription:Count the number of prime numbers less than a non-negative number, n. Solutionpublic class Solution { public int countPrimes(int n) { boolean[] notPrime = new boolean[n]; int count=0; for(int i=2;i&lt;n;i++){ if(notPrime[i]==false){ count++; int j=2; while(i*j&lt;=n-1){ notPrime[i*j]=true; j++; } } } return count; } } Thoughts:use boolean array to record if it is prime or notthe initial value of boolean is false","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 202 Happy number","slug":"leetcode-202-Happy-number","date":"2016-12-07T06:43:35.000Z","updated":"2016-12-07T06:47:41.000Z","comments":true,"path":"2016/12/06/leetcode-202-Happy-number/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-202-Happy-number/","excerpt":"Question: 202. Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1","text":"Question: 202. Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 Solution12345678910111213141516public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int sum = 0; while(set.add(n))&#123; sum=0; while(n&gt;0)&#123; sum +=(n%10)*(n%10); n=n/10; &#125; if(sum==1) return true; n=sum; &#125; return false; &#125;&#125; Thoughts Endless cycle is the hint for using the set to track the numbers since if it is endless cycle, it must return the same number again. Use a while loop to keep summing the numbers","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"},{"name":"math","slug":"math","permalink":"http://xytian315.github.io/tags/math/"}]},{"title":"leetcode 136 Single number","slug":"leetcode-136-Single-number","date":"2016-12-07T05:18:33.000Z","updated":"2016-12-07T06:44:11.000Z","comments":true,"path":"2016/12/06/leetcode-136-Single-number/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-136-Single-number/","excerpt":"Question: 136. Single NumberGiven an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?","text":"Question: 136. Single NumberGiven an array of integers, every element appears twice except for one. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//the solution from discussion//O(n) time 0 extra space//A XOR A = 0 and the XOR operator is commutativepublic class Solution &#123; public int singleNumber(int[] nums) &#123; int result = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; result=result^nums[i]; &#125; return result; &#125;&#125;//mysolution1 O(n) time O(n) extra spacepublic class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums.length==1) return nums[0]; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int element: nums)&#123; if(!set.add(element))&#123; set.remove(element); &#125;else&#123; set.add(element); &#125; &#125; Object[] result =set.toArray() return (int)result[0]; &#125;&#125;//mysolution2 O(n) time O(n) extra spacepublic class Solution &#123; public int singleNumber(int[] nums) &#123; if(nums.length==1) return nums[0]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int element: nums)&#123; if(map.containsKey(element))&#123; map.put(element,map.get(element)+1); &#125;else&#123; map.put(element,1); &#125; &#125; for(int element:nums)&#123; if(map.get(element)==1) return element; &#125; return nums[0]; &#125;&#125; Thoughtsif without extra space, thinking about bit manipulation?XOR bitwise manipulation A XOR A = 0; A XOR A XOR B = B;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 36 valid sudoku","slug":"leetcode-36-valid-sudoku","date":"2016-12-07T04:31:17.000Z","updated":"2016-12-07T04:46:07.000Z","comments":true,"path":"2016/12/06/leetcode-36-valid-sudoku/","link":"","permalink":"http://xytian315.github.io/2016/12/06/leetcode-36-valid-sudoku/","excerpt":"Question: 36. Valid SudokuDetermine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.","text":"Question: 36. Valid SudokuDetermine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; //validate rows if (!validate(i, i + 1, 0, 9, board)) return false; //validate cols if (!validate(0, 9, i, i + 1, board)) return false; &#125; //validate cells for (int i = 0; i &lt; 9; i += 3) &#123; for (int j = 0; j &lt; 9; j += 3) &#123; if (!validate(i, i + 3, j, j + 3, board)) return false; &#125; &#125; return true; &#125; public boolean validate(int rowStart, int rowEnd, int colStart, int colEnd, char[][] board) &#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for (int i = rowStart; i &lt; rowEnd; i++) &#123; for (int j = colStart; j &lt; colEnd; j++) &#123; if (!set.add(board[i][j]) &amp;&amp; board[i][j] != '.') &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;//my first time solutionpublic class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; //validate rows for (int i = 0; i &lt; 9; i++) &#123; if (!validate(i, i + 1, 0, 9, board)) return false; &#125; //validate columns for (int i = 0; i &lt; 9; i++) &#123; if (!validate(0, 9, i, i + 1, board)) return false; &#125; //validate cells for (int i = 0; i &lt; 9; i += 3) &#123; for (int j = 0; j &lt; 9; j += 3) &#123; if (!validate(i, i + 3, j, j + 3, board)) return false; &#125; &#125; return true; &#125; public boolean validate(int rowStart, int rowEnd, int colStart, int colEnd, char[][] board) &#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for (int i = rowStart; i &lt; rowEnd; i++) &#123; for (int j = colStart; j &lt; colEnd; j++) &#123; if (!set.add(board[i][j]) &amp;&amp; board[i][j] != '.') &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; Thoughts Soduku will be always 9rows 9 columns I don’t need to get the length like this board.length always checking if we can refactor it. make it DRY","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 414 Third Maximum number","slug":"leetcode-414-Third-Maximum-number","date":"2016-12-06T05:55:27.000Z","updated":"2016-12-06T05:58:09.000Z","comments":true,"path":"2016/12/05/leetcode-414-Third-Maximum-number/","link":"","permalink":"http://xytian315.github.io/2016/12/05/leetcode-414-Third-Maximum-number/","excerpt":"Question: 414. Third Maximum NumberGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1:Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.Example 2:Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.","text":"Question: 414. Third Maximum NumberGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1:Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1.Example 2:Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1] Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. Solution123456789101112131415161718192021222324public class Solution &#123; public int thirdMax(int[] nums) &#123; long max = Long.MIN_VALUE; long mid = Long.MIN_VALUE;; long min = Long.MIN_VALUE; for(int i: nums)&#123; if(i&gt;max)&#123; min=mid; mid=max; max=i; &#125;else if(i&lt;max &amp;&amp; i&gt;mid)&#123; min=mid; mid=i; &#125;else if(i&gt;min &amp;&amp; i&lt;mid)&#123; min=i; &#125; &#125; if(min!=Long.MIN_VALUE)&#123; return (int)min; &#125;else&#123; return (int)max; &#125; &#125;&#125; Thoughtsshould use long to initiate min value","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 88 Merge sorted array","slug":"leetcode-88-merge-sorted-array-0","date":"2016-12-06T00:37:50.000Z","updated":"2016-12-06T05:14:13.000Z","comments":true,"path":"2016/12/05/leetcode-88-merge-sorted-array-0/","link":"","permalink":"http://xytian315.github.io/2016/12/05/leetcode-88-merge-sorted-array-0/","excerpt":"Question: 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.","text":"Question: 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//not good solution did by myselfpublic class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int start1=0; int start2=0; int start =0; int[] temp = nums1.clone(); while(start1&lt;m &amp;&amp; start2&lt;n)&#123; if(temp[start1]&lt;=nums2[start2])&#123; nums1[start]=temp[start1]; start1++; &#125;else&#123; nums1[start]=nums2[start2]; start2++; &#125; start++; &#125; if(start1!=m)&#123; while(start1&lt;m)&#123; nums1[start]=temp[start1]; start1++; start++; &#125; &#125; if(start2!=n)&#123; while(start2&lt;n)&#123; nums1[start]=nums2[start2]; start2++; start++; &#125; &#125; &#125;&#125;//better solution after reading the discussionpublic class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i=m-1; int j=n-1; int index = m+n-1; while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i]&gt;=nums2[j])&#123; nums1[index]=nums1[i]; i--; &#125;else&#123; nums1[index]=nums2[j]; j--; &#125; index--; &#125; while(j&gt;=0)&#123; nums1[index]=nums2[j]; j--; index--; &#125; &#125;&#125; Thoughtswhen doing things in place in array, thinking about starting backwords.also noted after comparing two array, we only need to check if nums2 is already finished do not need to check nums1 since nums1’s elements are already in the right place","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 27 remove element","slug":"leetcode-27-remove-element-0","date":"2016-12-04T20:28:35.000Z","updated":"2016-12-06T05:13:22.000Z","comments":true,"path":"2016/12/04/leetcode-27-remove-element-0/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-27-remove-element-0/","excerpt":"Question: 27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2.","text":"Question: 27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. Solution//my solution public class Solution { public int removeElement(int[] nums, int val) { int current =0; for(int i =0;i&lt;nums.length;i++){ if(nums[i]!=val){ nums[current]=nums[i]; current++; } } return current; } } Thoughtsreturn current not (current+1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 1 two sum","slug":"leetcode-1-two-sum","date":"2016-12-04T20:11:31.000Z","updated":"2016-12-07T05:33:35.000Z","comments":true,"path":"2016/12/04/leetcode-1-two-sum/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-1-two-sum/","excerpt":"Question: 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].","text":"Question: 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution12345678910111213141516public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0;i&lt;nums.length;i++)&#123; if(map.containsKey(target-nums[i]))&#123; result[0]=map.get(target-nums[i]); result[1]=i; return result; &#125;else&#123; map.put(nums[i], i); &#125; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 219 contains duplicate II","slug":"leetcode-219-contains-duplicate-II","date":"2016-12-04T18:17:25.000Z","updated":"2016-12-09T04:17:55.000Z","comments":true,"path":"2016/12/04/leetcode-219-contains-duplicate-II/","link":"","permalink":"http://xytian315.github.io/2016/12/04/leetcode-219-contains-duplicate-II/","excerpt":"Question: 219. Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.","text":"Question: 219. Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. Solution123456789101112131415//my solution use a hashmappublic class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; if(nums.length&lt;=1 || k&lt;1) return false; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i&lt; nums.length; i++)&#123; if(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i])&lt;=k))&#123; return true; &#125;else&#123; map.put(nums[i],i); &#125; &#125; return false; &#125;&#125; 1234567891011//better solution you can use hashset public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 217 contains duplicate","slug":"leetcode-217-contains-duplicate","date":"2016-12-03T23:21:20.000Z","updated":"2016-12-09T04:15:00.000Z","comments":true,"path":"2016/12/03/leetcode-217-contains-duplicate/","link":"","permalink":"http://xytian315.github.io/2016/12/03/leetcode-217-contains-duplicate/","excerpt":"Question: 217. Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.","text":"Question: 217. Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Solution123456789101112131415//time O(n) space O(n)public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; if(nums.length&lt;=1) return false; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i =0;i&lt;nums.length;i++)&#123; if(set.contains(nums[i]))&#123; return true; &#125;else&#123; set.add(nums[i]); &#125; &#125; return false; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"hash table","slug":"hash-table","permalink":"http://xytian315.github.io/tags/hash-table/"}]},{"title":"leetcode 121 best time to buy and sell stock","slug":"leetcode-121-best-time-to-buy-and-sell-stock","date":"2016-12-03T20:35:27.000Z","updated":"2016-12-06T05:12:56.000Z","comments":true,"path":"2016/12/03/leetcode-121-best-time-to-buy-and-sell-stock/","link":"","permalink":"http://xytian315.github.io/2016/12/03/leetcode-121-best-time-to-buy-and-sell-stock/","excerpt":"Question: 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0.","text":"Question: 121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. Solution1234567891011121314//after reading kadane's algorithm, I wrote this solution//O(n) timepublic class Solution &#123; public int maxProfit(int[] prices) &#123; int max = 0; if(prices.length == 0) return max; int start =prices[prices.length-1]; for(int i=prices.length-2;i&gt;=0;i--)&#123; start= Math.max(prices[i], start); max=Math.max(max,start-prices[i]); &#125; return max; &#125;&#125; 1234567891011121314151617181920//brute force//O(n2)timepublic class Solution &#123; public int maxProfit(int[] prices) &#123; int result =0; int index = prices.length-1; while(index&gt;=1)&#123; int j = index-1; while(j&gt;=0)&#123; int profit = prices[index]-prices[j]; if(profit&gt;result)&#123; result=profit; &#125; j--; &#125; index--; &#125; return result; &#125;&#125; Thoughtsmax subarray problem (kadane’s algorithm) https://en.wikipedia.org/wiki/Maximum_subarray_problem Kadane’s algorithm consists of a scan through the array values, computing at each position the maximum (positive sum) subarray ending at that position. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous position. The algorithm only needs to keep track of the ending position because the implied starting position is just after the last position at which the sum went negative; a higher sum can always be found by dropping any negative-sum prefix. Thus, the problem can be solved with the following code, expressed here in Python: def max_subarray(A): max_ending_here = max_so_far = 0 for x in A: max_ending_here = max(0, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 119 pascals traingle II","slug":"leetcode-119-pascals-traingle-II","date":"2016-12-03T06:31:44.000Z","updated":"2016-12-06T05:12:54.000Z","comments":true,"path":"2016/12/02/leetcode-119-pascals-traingle-II/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-119-pascals-traingle-II/","excerpt":"Question: 119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space?","text":"Question: 119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? Solution123456789101112131415161718192021//My solution, not O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; List&lt;Integer&gt; last = new ArrayList&lt;Integer&gt;(); last.add(1); if(rowIndex==0) return last; for(int j =1; j&lt;=rowIndex; j++)&#123; result = new ArrayList&lt;Integer&gt;(); result.add(1); for(int i=0;i&lt;last.size()-1;i++)&#123; result.add(last.get(i)+last.get(i+1)); &#125; result.add(1); last = result; &#125; return result; &#125;&#125; 1234567891011121314//O(k) spacepublic class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(rowIndex&lt;0) return result; for(int i=0; i&lt;=rowIndex;i++)&#123; result.add(1); for(int j=i-1;j&gt;0;j--)&#123; result.set(j, result.get(j)+result.get(j-1)); &#125; &#125; return result; &#125;&#125; Thoughts思路： 从后往前算 in place replace","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 118 pascal's triangle","slug":"leetcode-118-pascal-s-triangle","date":"2016-12-03T05:35:44.000Z","updated":"2016-12-06T05:12:51.000Z","comments":true,"path":"2016/12/02/leetcode-118-pascal-s-triangle/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-118-pascal-s-triangle/","excerpt":"Question: 118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]","text":"Question: 118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Solution123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(numRows&lt;=0) return result; List&lt;Integer&gt; first = new ArrayList&lt;Integer&gt;(); first.add(1); result.add(first); for(int i=2;i&lt;=numRows;i++)&#123; List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; last = result.get(result.size()-1); current.add(1); for(int j=0;j&lt;last.size()-1;j++)&#123; current.add(last.get(j)+last.get(j+1)); &#125; current.add(1); result.add(current); &#125; return result; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 283 Move zeroes","slug":"leetcode-283-Move-zeroes","date":"2016-12-03T03:19:28.000Z","updated":"2016-12-06T05:13:25.000Z","comments":true,"path":"2016/12/02/leetcode-283-Move-zeroes/","link":"","permalink":"http://xytian315.github.io/2016/12/02/leetcode-283-Move-zeroes/","excerpt":"Question: 283. Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations.","text":"Question: 283. Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. Solution1234567891011121314151617public class Solution &#123; public void moveZeroes(int[] nums) &#123; int i =0; int count =0; while(i&lt;nums.length)&#123; if(nums[i]!=0)&#123; nums[count]=nums[i]; count++; &#125; i++; &#125; while(count&lt;nums.length)&#123; nums[count]=0; count++; &#125; &#125;&#125; Thoughts思路：O(n)time O(1) space1.loop the array from the beginning, use a slow runner to keep tracking the current index, if it is none zero, put that in the current index place. otherwise, continue.2.put 0 to the remaining indexes.","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 448 Find All Numbers Disappeared in an Array","slug":"leetcode-448-Find-All-Numbers-Disappeared-in-an-Array","date":"2016-12-02T06:47:49.000Z","updated":"2016-12-06T05:13:33.000Z","comments":true,"path":"2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","link":"","permalink":"http://xytian315.github.io/2016/12/01/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","excerpt":"","text":"Question: Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] Thoughts:思路：第一种简单解法O(n) space O(n) time1把数组中的所有数字放到一个set中2loop 从1到n, 如果数字i不在set中，即是答案disappeared number第二种优化解法O(1) space O(n)time1用index来标记是否数字出现于数组中， 如果数字在数组中，相应的index变成负数。nums[nums[i]-1] = -nums[nums[i]-1]2loop array, 如果数字是正数，说明这个数字没有出现在数组中，既是答案注：因为index是从0开始的，0到n-1, 而我们需要1到n, 所以纪录时要减1，最后结果要加1 Solution12345678910111213141516//O(n) space O(n) timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i =0; i&lt;nums.length;i++)&#123; set.add(nums[i]); &#125; for(int i=1; i&lt;= nums.length;i++)&#123; if(!set.contains(i))&#123; result.add(i); &#125; &#125; return result; &#125;&#125; 12345678910111213141516171819// NO extra space solution O(1) space O(n)timepublic class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for(int i =0 ; i&lt;nums.length; i++)&#123; int value = Math.abs(nums[i])-1; if(nums[value]&gt;0)&#123; nums[value] = -nums[value]; &#125; &#125; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;0)&#123; result.add(i+1); &#125; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 26 Remove Duplicates from Sorted Array","slug":"leetcode-26","date":"2016-10-03T23:13:09.000Z","updated":"2017-04-26T05:04:55.000Z","comments":true,"path":"2016/10/03/leetcode-26/","link":"","permalink":"http://xytian315.github.io/2016/10/03/leetcode-26/","excerpt":"Question: 26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.","text":"Question: 26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. Thoughts:Two pointer techniquehttps://leetcode.com/articles/two-pointer-technique/two pointer: one fast runner, one slow runner Solutionfirst time12345678910111213141516public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0 || nums.length == 1) return nums.length; int current = nums[0]; int count = 1; for(int i=1; i&lt; nums.length; i++) &#123; if(nums[i] != current) &#123; current = nums[i]; nums[count] = nums[i]; count++; &#125; &#125; return count; &#125;&#125; second time(04/25/2017)1234567891011121314151617181920212223242526272829303132333435//two pointerspublic class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length==0 || nums.length==1) return nums.length; int slow = 0; int fast = 1; while(fast &lt;= nums.length-1)&#123; while(fast&lt;= nums.length-1 &amp;&amp; nums[slow]==nums[fast] )&#123; fast++; &#125; if(fast&lt;=nums.length-1)&#123; nums[slow+1]=nums[fast]; slow++; fast++; &#125; &#125; return slow+1; &#125;&#125;//refactor 遇到不相同的数才挪动慢指针public class Solution &#123; public int removeDuplicates(int[] nums)&#123; if(nums.length == 0) return 0; int slow = 0; for(int fast = 1; fast&lt;=nums.length-1; fast++)&#123; if(nums[fast] != nums[slow])&#123; nums[slow+1] = nums[fast]; slow++; &#125; &#125; return slow+1; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 189 Rotate Array","slug":"leetcode-189","date":"2016-09-12T19:06:08.000Z","updated":"2016-12-06T07:59:03.000Z","comments":true,"path":"2016/09/12/leetcode-189/","link":"","permalink":"http://xytian315.github.io/2016/09/12/leetcode-189/","excerpt":"","text":"Question: 189. Rotate ArrayRotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Solution12345678910111213141516171819//O(n) time o(1) spacepublic class Solution &#123; public void rotate(int[] nums, int k) &#123; if(k==0 || nums.length&lt;=1) return; k=k%nums.length; reverse(nums,0,nums.length-1); reverse(nums,0, k-1); reverse(nums,k, nums.length-1); &#125; public void reverse(int[] nums,int start, int end)&#123; while(start&lt;end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125; Thoughts Don’t forget to do k=k%nums.length; use a customized method to do common things: in this case reverse the array","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 11 Container With Most Water","slug":"leetcode-11","date":"2016-09-09T02:44:35.000Z","updated":"2016-12-06T05:12:48.000Z","comments":true,"path":"2016/09/08/leetcode-11/","link":"","permalink":"http://xytian315.github.io/2016/09/08/leetcode-11/","excerpt":"Question: 11. Container With Most Waterhttps://leetcode.com/problems/container-with-most-water/Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container.","text":"Question: 11. Container With Most Waterhttps://leetcode.com/problems/container-with-most-water/Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. Solution12","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://xytian315.github.io/tags/two-pointers/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"leetcode 169 Majority element","slug":"leetcode-169-Majority-element","date":"2016-09-01T06:12:06.000Z","updated":"2016-12-06T05:13:00.000Z","comments":true,"path":"2016/08/31/leetcode-169-Majority-element/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-169-Majority-element/","excerpt":"Question: 169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array.","text":"Question: 169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution1234567891011121314151617181920212223242526/** my solution sort**/public class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125;/** my solution map notes: remember to return immediately if the value is more n/2 times **/public class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums.length == 1) return nums[0]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt; nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; if(map.get(nums[i])&gt;=nums.length/2) return nums[i]; map.replace(nums[i], map.get(nums[i])+1); &#125;else&#123; map.put(nums[i], 1); &#125; &#125; return 0; &#125;&#125; Thoughtssort will be o(nlog) time; hashmap will be o(n) timethere are also another genius solution o(n) time o(1) space so called Moores’s Voting algorithmhttps://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution12345678910111213141516public class Solution &#123; public int majorityElement(int[] num) &#123; int major=num[0], count = 1; for(int i=1; i&lt;num.length;i++)&#123; if(count==0)&#123; count++; major=num[i]; &#125;else if(major==num[i])&#123; count++; &#125;else count--; &#125; return major; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 66 Plus one","slug":"leetcode-66-Plus-one","date":"2016-09-01T05:43:16.000Z","updated":"2017-02-01T08:30:07.000Z","comments":true,"path":"2016/08/31/leetcode-66-Plus-one/","link":"","permalink":"http://xytian315.github.io/2016/08/31/leetcode-66-Plus-one/","excerpt":"Question: 66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list.","text":"Question: 66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** my first time solution 08/31/2016 */public class Solution &#123; public int[] plusOne(int[] digits) &#123; int i = digits.length-1; int carry = 0; digits[i] = digits[i]+1; while(i&gt;=0)&#123; digits[i] = digits[i]+carry; if(digits[i]&gt;=10)&#123; digits[i] = digits[i]-10; carry=1; &#125;else&#123; carry=0; &#125; i--; &#125; if(carry == 0)&#123; return digits; &#125;else&#123; int[] result = new int[digits.length+1]; result[0]=1; int index=0; int j=1; while(index&lt;digits.length)&#123; result[j] = digits[index]; j++; index++; &#125; return result; &#125; &#125;&#125;//second time solution 01/31/2017public class Solution &#123; public int[] plusOne(int[] digits) &#123; if(digits.length==0) return digits; int count; digits[digits.length-1]+=1; if(digits[digits.length-1]&gt;=10)&#123; count=1; digits[digits.length-1]=0; &#125;else&#123; count=0; &#125; int index=digits.length-2; while(index&gt;=0)&#123; digits[index]=digits[index]+count; if(digits[index]&gt;=10)&#123; digits[index]=0; count=1; &#125;else&#123; count=0; &#125; index--; &#125; if(digits[0]==0)&#123; int[] result = new int[digits.length+1]; result[0]=1; int i=0; while(i&lt;=digits.length-1)&#123; result[i+1]=digits[i]; i++; &#125; return result; &#125; return digits; &#125;&#125;//better and cleaner solution!public int[] plusOne(int[] digits) &#123; int n = digits.length; for(int i=n-1; i&gt;=0; i--) &#123; if(digits[i] &lt; 9) &#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newNumber = new int [n+1]; newNumber[0] = 1; return newNumber;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"http://xytian315.github.io/tags/array/"}]},{"title":"leetcode 7 Reverse Integer","slug":"leetcode-7-Reverse-Integer","date":"2016-08-10T04:34:29.000Z","updated":"2017-01-31T08:03:23.000Z","comments":true,"path":"2016/08/09/leetcode-7-Reverse-Integer/","link":"","permalink":"http://xytian315.github.io/2016/08/09/leetcode-7-Reverse-Integer/","excerpt":"Question: 7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321","text":"Question: 7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Solution123456789101112131415public class Solution &#123; public int reverse(int x) &#123; int result = 0; int tail,newResult; while(x!=0)&#123; tail=x%10; newResult=result*10+tail; if((newResult-tail)/10!=result) return 0; result=newResult; x=x/10; &#125; return result; &#125;&#125; Thoughts: keep moving the tail into the front and mutliply by 10 There is no difference between positive and negative nubmer while(x!=0) Do not forget to think about overflow problem. use newResult and result to check","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"http://xytian315.github.io/tags/easy/"}]},{"title":"leetcode 6 ZigZag Conversion","slug":"leetcode-6","date":"2016-08-09T04:47:46.000Z","updated":"2016-12-06T05:13:40.000Z","comments":true,"path":"2016/08/08/leetcode-6/","link":"","permalink":"http://xytian315.github.io/2016/08/08/leetcode-6/","excerpt":"Question: 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/","text":"Question: 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.https://leetcode.com/problems/zigzag-conversion/ Solution12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if (s == null || s.isEmpty() || numRows &lt;= 1 || numRows &gt;= s.length()) return s; int length = s.length(); int step = 2*(numRows-1); int count = 0; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; numRows; i++)&#123; int interval = step-2*i; for(int j = i; j &lt; length; j+=step)&#123; sb.append(s.charAt(j)); count++; if(interval &gt;0 &amp;&amp; interval != step &amp;&amp; count &lt; length &amp;&amp; (j+interval)&lt;length )&#123; sb.append(s.charAt(j+interval)); count++; &#125; &#125; &#125; return sb.toString(); &#125;&#125; Thoughts:I have no idea how to do this question at first, stucking for a whilehere is the solution https://kevinclcn.gitbooks.io/leetcodejava/content/006_zigzag_conversion.html","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"}]},{"title":"leetcode 5 Longest Palindromic Substring","slug":"leetcode-5","date":"2016-08-05T14:00:47.000Z","updated":"2016-12-06T05:13:37.000Z","comments":true,"path":"2016/08/05/leetcode-5/","link":"","permalink":"http://xytian315.github.io/2016/08/05/leetcode-5/","excerpt":"Question: 5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.","text":"Question: 5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Solution12345678910111213141516171819202122232425262728/* * I only did the brute force solution O(n3) */ public class Solution &#123; public String longestPalindrome(String s) &#123; if(s.isEmpty() || s.length() == 1) return s; String result = \"\"; for(int i = 0; i &lt; s.length(); i++)&#123; for(int j = i+1; j&lt; s.length(); j++)&#123; if(isPalindrome(s, i, j) &amp;&amp; result.length() &lt; j-i+1)&#123; result = s.substring(i,j+1); &#125; &#125; &#125; int return result; &#125; public Boolean isPalindrome(String s, int i , int j)&#123; while(i&lt;j)&#123; if(s.charAt(i)!=s.charAt(j)) return false; i++; j--; &#125; return true; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]},{"title":"leetcode 3 Longest Substring Without Repeating Characters","slug":"leetcode-3","date":"2016-08-04T23:44:34.000Z","updated":"2016-12-06T05:13:29.000Z","comments":true,"path":"2016/08/04/leetcode-3/","link":"","permalink":"http://xytian315.github.io/2016/08/04/leetcode-3/","excerpt":"Question: 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.","text":"Question: 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Solution1234567891011121314151617181920212223242526/**my solution without looking at the answers*/public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.isEmpty()) return 0; int result = 0; int start = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; if(map.containsKey(s.charAt(i))) &#123; if(result &lt; i - start ) &#123; result = i - start; &#125; if(map.get(s.charAt(i))+1 &gt; start)&#123; start = map.get(s.charAt(i)) + 1; &#125; &#125; map.put(s.charAt(i), i); &#125; if(result &lt; s.length()-start) &#123; result = s.length()-start; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"},{"name":"map","slug":"map","permalink":"http://xytian315.github.io/tags/map/"}]},{"title":"how to implement a singly LinkedList","slug":"how-to-implement-a-singly-LinkedList","date":"2016-08-02T23:02:36.000Z","updated":"2016-12-06T05:12:38.000Z","comments":true,"path":"2016/08/02/how-to-implement-a-singly-LinkedList/","link":"","permalink":"http://xytian315.github.io/2016/08/02/how-to-implement-a-singly-LinkedList/","excerpt":"","text":"Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SinglyLinkedList&lt;E&gt; &#123; /** * Nested node class */ private static class Node&lt;E&gt; &#123; private E element; private Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; public E getElement() &#123; return this.element; &#125; public Node&lt;E&gt; getNext() &#123; return this.next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; /** * end of nested node class */ private Node&lt;E&gt; head = null; private Node&lt;E&gt; tail = null; private Integer size = 0; public SinglyLinkedList() &#123; &#125; public Integer size() &#123; return this.size; &#125; public Boolean isEmpty() &#123; return this.size == 0; &#125; public E first() &#123; if(isEmpty()) return null; return head.getElement(); &#125; public E last() &#123; if(isEmpty()) return null; return tail.getElement(); &#125; public void addFirst(E e) &#123; Node&lt;E&gt; newHead = new Node(e, head); this.head = newHead; size++; &#125; public void addLast(E e) &#123; Node&lt;E&gt; newNode = new Node(e, null); if(isEmpty())&#123; head = newNode; &#125;else &#123; tail.setNext(newNode); this.tail = newNode; &#125; size++; &#125; public E removeFirst() &#123; if(isEmpty()) return null; E result = head.getElement(); this.head = head.getNext(); size--; return result; &#125;&#125; NotesNested class: when defining a class which is strongly affiliated with another class helps to increase encapsulation and avoid name conflicts Static means its value/method is associated with the class itself, rather than with each individual instance of the class.That means it is not invoked on a particular instance of the class using traditional dot notation.Instead, it is typically using the name of the class as a qualifier. useful for providing utility behaviors related to a class that need not rely on the state of any particular instance of the class.","categories":[],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"}]},{"title":"leetcode 2 Add Two Numbers","slug":"leetcode-2-Add-two-numbers","date":"2016-07-20T06:34:59.000Z","updated":"2016-12-06T05:13:09.000Z","comments":true,"path":"2016/07/19/leetcode-2-Add-two-numbers/","link":"","permalink":"http://xytian315.github.io/2016/07/19/leetcode-2-Add-two-numbers/","excerpt":"Question: 2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8","text":"Question: 2. Add Two Numbershttps://leetcode.com/problems/add-two-numbers/You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ /** Wrote the following solution without seeing other people's solutions **/public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode tail = null; int count = 0; while(l1 != null || l2 != null) &#123; if(l1 != null)&#123; count += l1.val; l1 = l1.next; &#125; if(l2 != null) &#123; count += l2.val; l2 = l2.next; &#125; ListNode ln = new ListNode(count%10); if(head == null) &#123; head = ln; tail = ln; &#125;else &#123; tail.next = ln; tail=ln; &#125; count = count/10; &#125; if(count&gt;0) &#123; tail.next= new ListNode(count); &#125; return head; &#125;&#125; Thoughts","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://xytian315.github.io/tags/leetcode/"},{"name":"linked list","slug":"linked-list","permalink":"http://xytian315.github.io/tags/linked-list/"},{"name":"medium","slug":"medium","permalink":"http://xytian315.github.io/tags/medium/"}]}]}